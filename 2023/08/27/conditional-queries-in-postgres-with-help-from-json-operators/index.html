<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/blog.css"><title>Lorefnon | Blog | Conditional Queries in Postgres with help from JSON Operators</title><meta property="og:title" content="Lorefnon | Blog | Conditional Queries in Postgres with help from JSON Operators"><meta property="og:description" content="Ramblings on Web Development and software architecture"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="icon" href="/images/favicon/favicon.ico"><script data-goatcounter="https://analytics.lorefnon.com/count" async src="https://analytics.lorefnon.com/count.js"></script><script src="https://unpkg.com/htmx.org@1.7.0/dist/htmx.min.js" defer></script><script src="https://unpkg.com/dompurify@2.3.6/dist/purify.min.js" defer></script><script src="/js/blog.js" defer></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Icicles of Thought" type="application/atom+xml">
</head><body class="blog-body" hx-boost="true"><div class="blog-summary"><a class="primary-link" href="/" hx-boost="false"><h1 class="header-text">Gaurab Paul</h1><h2 class="header-text">Polyglot software developer &amp; consultant passionate about web development, distributed systems and open source technologies</h2></a><div class="blog-support"><div class="blog-support-cta-container"><a class="blog-support-btn" href="https://ko-fi.com/lorefnon" target="_blank" title="Support my work"></a></div></div></div><div class="blog-sidebar"><div class="blog-support"><div class="blog-support-cta-container"><a class="blog-support-btn" href="https://ko-fi.com/lorefnon" target="_blank" title="Support my work"></a><div class="blog-support-arrow"></div><p class="support-text body-text">Support my blog and open-source work</p></div></div><h1 class="header-text">Tags</h1><ul class="tag-list"><li class="body-text"><a class="tag-link" href="/tags/Postgres/"><img src="/images/tag.svg">Postgres</a></li><li class="body-text"><a class="tag-link" href="/tags/JSON/"><img src="/images/tag.svg">JSON</a></li></ul></div><div class="blog-header blog-post-header"><div class="blog-post-header-inner"><div class="header-text">Conditional Queries in Postgres with help from JSON Operators</div><div class="posted-date sub-header-text" title="2023-08-26">Posted &nbsp;3 months ago</div><hr class="blog-header-separator"></div></div><div class="blog-main"><div class="page-content"><p>For many mainstream languages we have query builder libraries that enable us to easily create <code>select</code> queries with complex <code>where</code> conditions that conditionally filter by multiple columns based on incoming input. These are often useful for things like a filter panel in product catalogue where user may specify one or more of several possible criteria.</p>
<p>This post outlines an alternative solution. If we structure our input parameter as json (or any other compound data type for that matter), we can handle the conditional clauses within SQL with some creativity.</p>
<p>For example, to find users by id or email, we can do something like this: </p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">from</span> &quot;user&quot; u 
<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_email ue 
    <span class="hljs-keyword">on</span> ue.user_id <span class="hljs-operator">=</span> u.id
<span class="hljs-keyword">where</span> 
    (
        <span class="hljs-comment">-- Filter conditions</span>
        ($<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> u.id <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span>)::<span class="hljs-type">bigint</span> ) <span class="hljs-keyword">or</span>
        ($<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> ue.email <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span>))
    ) <span class="hljs-keyword">and</span>

    <span class="hljs-comment">-- Fallback to ensure that nothing is selected if no filters are passed</span>
    ($<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> $<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>)</code></pre>

<p>We can pass input parameters like: <code>&#123; &quot;id&quot;: &#123; &quot;eq&quot;: 1 &#125; &#125;</code> or <code>&#123; &quot;email&quot;: &#123; &quot;eq&quot;: &quot;lorefnon@tutanota.com&quot; &#125; &#125;</code> and it will filter appropriately.</p>
<p>We can skip the jsonb cast if our client library allows us to cast parameters while passing to database</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">from</span> &quot;user&quot; u 
<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_email ue 
    <span class="hljs-keyword">on</span> ue.user_id <span class="hljs-operator">=</span> u.id
<span class="hljs-keyword">where</span> 
    (
        <span class="hljs-comment">-- Filter conditions</span>
        (($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> u.id <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span>)::<span class="hljs-type">bigint</span> ) <span class="hljs-keyword">or</span>
        (($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> ue.email <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span>))
    ) <span class="hljs-keyword">and</span>

    <span class="hljs-comment">-- Fallback to ensure that nothing is selected if no filters are passed</span>
    ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> $<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>)</code></pre>

<p>While this is arguably more verbose and less readable (due to the use of non-intuitive json operators), there are a few benefits to this approach.</p>
<p>One is that we don&#39;t need a complex query builder library, which may be a plus if we are working with a niche language and&#x2F;or a restricted runtime like openresty. </p>
<p>Other is that this approach pairs well with prepared statements and the query can be parsed and analyzed just once - if we use a query builder to create slightly differing SELECT statements for various use cases, they would need to be parsed separately each time. Of course, we are trading off per-execution query parsing with per-execution json parsing, but if our json is not very complex, the parsing overhead is lower.</p>
<p>One apparent limitation is that we can not perform conditional joins. However, that can often be alleviated with usage of unions:</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">from</span> &quot;user&quot; u
<span class="hljs-keyword">where</span> 
    ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> u.id <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span>)::<span class="hljs-type">bigint</span>

<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> 

<span class="hljs-keyword">select</span> u.<span class="hljs-operator">*</span> 
<span class="hljs-keyword">from</span> &quot;user&quot; u
<span class="hljs-keyword">join</span> user_email ue
    <span class="hljs-keyword">on</span> ue.user_id <span class="hljs-operator">=</span> u.id
<span class="hljs-keyword">where</span>
    ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> ue.email <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email, eq&#125;&#x27;</span>)</code></pre>

<p>or, by building up subselections for individual filters in CTE steps and then combining them in the final select:</p>
<pre><code class="hljs sql"><span class="hljs-comment">-- CTE Steps for each possible criteria</span>
<span class="hljs-keyword">with</span> user_fby_email <span class="hljs-keyword">as</span> (
    <span class="hljs-keyword">select</span> ue.user_id 
    <span class="hljs-keyword">from</span> user_email ue
    <span class="hljs-keyword">where</span> ($<span class="hljs-number">1</span>::json #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> ue.email <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span>::json #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;email,eq&#125;&#x27;</span>)
)

<span class="hljs-comment">-- Directly handle the criteria for user table (for which an additional subquery is unnecessary)</span>
<span class="hljs-keyword">select</span> u.<span class="hljs-operator">*</span>
<span class="hljs-keyword">from</span> &quot;user&quot; u
<span class="hljs-keyword">where</span> (($<span class="hljs-number">1</span> #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> u.id <span class="hljs-operator">=</span> ($<span class="hljs-number">1</span>::jsonb #<span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;&#123;id,eq&#125;&#x27;</span>)::<span class="hljs-type">bigint</span> ))

<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>

<span class="hljs-comment">-- Merge users for each criteria</span>
<span class="hljs-keyword">select</span> u.<span class="hljs-operator">*</span>
<span class="hljs-keyword">from</span> &quot;user&quot; u
<span class="hljs-keyword">where</span> u.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> user_id <span class="hljs-keyword">from</span> user_fby_email)</code></pre>

<p>The latter tends to be more readable when there are many possible filter criteria.</p>
<p>When using multiple tables, these approaches are likely to enable better index utilization.</p>
<p>We do need to analyze EXPLAIN queries with all possible combinations of inputs to ensure that indexes are properly utilized - but that is something we would have needed when using query builders or ORMs too.</p>
</div><div class="post-comments"><!-- .comments-target--></div><div class="post-comments" style="margin-top: 10px;"><div id="remark42"></div></div></div><div class="blog-footer body-text"><p class="copyright-container"><strong>Â© 2022 Gaurab Paul</strong></p><p>Unless otherwise mentioned in specific contexts, all code is licensed under the The MIT License and all content and artwork is licensed under CC BY-NC-SA.</p><p>The opinions expressed herein are author's personal viewpoints and may not be taken as professional recommendations from any of his previous or current employers.</p></div></body></html>