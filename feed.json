{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2022/09/04/getting-started-with-jet-query-builder-for-golang/",
            "url": "https://lorefnon.me/2022/09/04/getting-started-with-jet-query-builder-for-golang/",
            "title": "Getting started with Jet Query builder for Go",
            "date_published": "2022-09-04T00:00:00.000Z",
            "content_html": "<p>I was recently looking for a good query builder for a go application I am prototyping, and settled on <a href=\"https://github.com/go-jet/jet\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Jet</a>. Jet has a nice <a href=\"https://github.com/go-jet/jet/wiki\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">wiki</a>, but limited introductory material as of this writing, so this post is an attempt to collect a set of small recipies to help you get started with it quicker.</p>\n<h2 id=\"Why-Jet\"><a href=\"#Why-Jet\" class=\"headerlink\" title=\"Why Jet ?\"></a>Why Jet ?</h2><p>Usually larger applications tend to adopt fully featured ORMs early on, where as smaller micro-services often eschew the complexity that comes with a full ORM and directly use the low level database adapters.</p>\n<p>Query builders like jet sit somewhere between the two in the abstraction ladder. </p>\n<p>Unlike a full ORM it doesn&#39;t have features like dirty tracking, model lifecycle hooks etc. </p>\n<p>Also unlike directly using a database driver, it provides a type-safe API to construct SQL queries which I find much more ergonomic and less error-prone than raw parameterized queries or (ugh) constructing complex sql with string interpolations.</p>\n<p>Jet fits a sweet spot for me, because: </p>\n<ol>\n<li>It is not overly opinionated around how database should be accessed.</li>\n<li>Whatever you can do with SQL, you can also do with Jet</li>\n<li>It is performant, very little overhead over direct SQL</li>\n<li>It is type-safe - no ugly string interpolations, no SQL syntax errors in corner cases.</li>\n<li>The API closely matches the SQL syntax - so less learning curve is required</li>\n</ol>\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use ?\"></a>How to use ?</h2><p>Jet is easy to get started with. It is designed to work with the <code>database/sql</code> package in go stdlib, and only offers a query builder. The database&#x2F;sql package is used for actually executing the queries on the database.</p>\n<p>In this post we will use a sqlite, but jet offers support for most mainstream databases.</p>\n<h3 id=\"Configuring-the-codegenerator\"><a href=\"#Configuring-the-codegenerator\" class=\"headerlink\" title=\"Configuring the codegenerator\"></a>Configuring the codegenerator</h3><p>Jet offers what is called a database-first approach. In this approach, you update your database first (a migration system is recommended) and then generate code from the database for all your tables. </p>\n<p>This ensures that the table mapping code is always up-to-date and you don&#39;t need to specify every column being added twice - once when updating the database, and once in application code. </p>\n<p>Let us say we have following sql tables defined in test.sqlite3: </p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span>\n  notebook (id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">36</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key, title <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">500</span>));\n\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span>\n  note (\n    id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">36</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key,\n    title <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">500</span>),\n    notebook_id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">36</span>) <span class=\"hljs-keyword\">references</span> notebook (id) <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">delete</span> cascade <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> restrict\n  );</code></pre>\n\n<p>To generate the code, we&#39;ll first need to install the jet cli. We will also need to ensure that the specific database drivers we need are enabled through build tags: </p>\n<pre><code class=\"hljs plaintext\">go install -tags &#x27;sqlite3&#x27; github.com/go-jet/jet/v2/cmd/jet@latest</code></pre>\n\n<p>Note that you will need to change the tags if you are using another database.  Also if you are using sqlite, and need to use some of the sqlite extensions, you&#39;ll need additional build tags for those too, for example: </p>\n<pre><code class=\"hljs plaintext\">go install -tags &#x27;json1 fts5 sqlite3&#x27; github.com/go-jet/jet/v2/cmd/jet@latest</code></pre>\n\n<p>Inside a go project, we can generate the jet mapper code for this database using a command like: </p>\n<pre><code class=\"hljs plaintext\">jet -source=sqlite -dsn=&quot;/tmp/test.sqlite3&quot; -path=./gen/jet</code></pre>\n\n<p>if you use a migration system like dbmate, go-migrate or atlas, you&#39;d typically want to exclude the tables used only for migration bookkeeping.</p>\n<pre><code class=\"hljs plaintext\">jet -source=sqlite -dsn=&quot;/tmp/test.sqlite3&quot; -path=./gen/jet -ignore-tables=schema_migrations</code></pre>\n\n<p>Ok, so now let&#39;s look at the generated files: For every table we have a table mapper file and model file. For example for notebook we have the following table mapper file:</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// Code generated by go-jet DO NOT EDIT.</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// WARNING: Changes to this file may cause incorrect behavior</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// and will be lost if the code is regenerated</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">package</span> table\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> (\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-string\">&quot;github.com/go-jet/jet/v2/sqlite&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">var</span> Notebook = newNotebookTable(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;notebook&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">type</span> notebookTable <span class=\"hljs-keyword\">struct</span> {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tsqlite.Table\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">//Columns</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tID    sqlite.ColumnString\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tTitle sqlite.ColumnString\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tAllColumns     sqlite.ColumnList\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tMutableColumns sqlite.ColumnList\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">type</span> NotebookTable <span class=\"hljs-keyword\">struct</span> {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tnotebookTable\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tEXCLUDED notebookTable\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// AS creates new NotebookTable with assigned alias</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> AS(alias <span class=\"hljs-type\">string</span>) *NotebookTable {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> newNotebookTable(a.SchemaName(), a.TableName(), alias)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// Schema creates new NotebookTable with assigned schema name</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> FromSchema(schemaName <span class=\"hljs-type\">string</span>) *NotebookTable {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> newNotebookTable(schemaName, a.TableName(), a.Alias())\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// WithPrefix creates new NotebookTable with assigned table prefix</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> WithPrefix(prefix <span class=\"hljs-type\">string</span>) *NotebookTable {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> newNotebookTable(a.SchemaName(), prefix+a.TableName(), a.TableName())\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// WithSuffix creates new NotebookTable with assigned table suffix</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> WithSuffix(suffix <span class=\"hljs-type\">string</span>) *NotebookTable {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> newNotebookTable(a.SchemaName(), a.TableName()+suffix, a.TableName())\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newNotebookTable</span><span class=\"hljs-params\">(schemaName, tableName, alias <span class=\"hljs-type\">string</span>)</span></span> *NotebookTable {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> &amp;NotebookTable{\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tnotebookTable: newNotebookTableImpl(schemaName, tableName, alias),\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tEXCLUDED:      newNotebookTableImpl(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;excluded&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>),\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newNotebookTableImpl</span><span class=\"hljs-params\">(schemaName, tableName, alias <span class=\"hljs-type\">string</span>)</span></span> notebookTable {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">var</span> (\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tIDColumn       = sqlite.StringColumn(<span class=\"hljs-string\">&quot;id&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tTitleColumn    = sqlite.StringColumn(<span class=\"hljs-string\">&quot;title&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tallColumns     = sqlite.ColumnList{IDColumn, TitleColumn}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tmutableColumns = sqlite.ColumnList{TitleColumn}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> notebookTable{\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tTable: sqlite.NewTable(schemaName, tableName, alias, allColumns...),\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\t<span class=\"hljs-comment\">//Columns</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tID:    IDColumn,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tTitle: TitleColumn,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tAllColumns:     allColumns,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tMutableColumns: mutableColumns,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr></table></code></pre>\n\n<p>This file initializes the specific table objects for constructing SQL queries.</p>\n<p>We also have a model file which is a simple go struct representing a row in a table: </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// Code generated by go-jet DO NOT EDIT.</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// WARNING: Changes to this file may cause incorrect behavior</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">// and will be lost if the code is regenerated</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">package</span> model\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">type</span> Notebook <span class=\"hljs-keyword\">struct</span> {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tID    <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`sql:&quot;primary_key&quot;`</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tTitle *<span class=\"hljs-type\">string</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr></table></code></pre>\n\n<p>We will have this pair generated for each table in our db. </p>\n<h2 id=\"Executing-queries\"><a href=\"#Executing-queries\" class=\"headerlink\" title=\"Executing queries\"></a>Executing queries</h2><p>Now that we have our code generated, we can use the generated API to query our database. </p>\n<p>Jet&#39;s api closely matches the SQL syntax. So to fetch a note with known title we can do something like: </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> (\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tm <span class=\"hljs-string\">&quot;example.com/rts/gen/jet/model&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tt <span class=\"hljs-string\">&quot;example.com/rts/gen/jet/table&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tjet <span class=\"hljs-string\">&quot;github.com/go-jet/jet/v2/sqlite&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">query := t.Note.\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    SELECT(t.Notebook.AllColumns).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>))\n</td></tr></table></code></pre>\n\n<p>Note that this just creates the query. To actually execute it, we need a sql.DB instance. This would be created through the database&#x2F;sql package in go stdlib and is not jet specific. </p>\n<p>For SQLite all we need is the path to the database. For other database we can pass connection strings.</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">db, err := sql.Open(<span class=\"hljs-string\">&quot;sqlite3&quot;</span>, dbFilePath)\n</td></tr></table></code></pre>\n\n<p>Now we can run the query through the db instance and map the rows to our generated model structs: </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">var</span> notebooks []m.Notebook\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">err := t.Notebook.\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    SELECT(t.Notebook.AllColumns).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>)).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    Query(db, &amp;notebooks)\n</td></tr></table></code></pre>\n\n<p>If the query succeeds our notebooks slice will be populated with the fetched rows.</p>\n<p>Note that we didn&#39;t have to deal with untyped data at any point. </p>\n<p>We are also not restricted to using the generated model types. The generated model types are provided as a convenience for common crud operations, but we will often need to define custom types when fetching subset of columns or when fetching data from multiple tables. </p>\n<p>Let&#39;s say we want to fetch not only the notebook, but all associated notes. To represent a note along with member notes, we can define following struct which composes the generated models:</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">type</span> NotebookWithNotes <span class=\"hljs-keyword\">struct</span> {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    m.Notebook,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    Notes []m.Note\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr></table></code></pre>\n\n<p>and use that in our query:</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">var</span> notebooks []m.NotebookWithNotes\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">err := t.Notebook.\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    INNER_JOIN(t.Note, t.Note.NotebookID.EQ(t.Notebook.ID))\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    SELECT(t.Notebook.AllColumns).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>)).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    Query(db, &amp;notebooks)\n</td></tr></table></code></pre>\n\n<p>The join syntax is pretty similar to what we would have expected from SQL. Also we didn&#39;t have to do anything special here to support mapping the flattened rows to hierarchical model. jet is able to automatically identify the Notebook fields from embedded struct and the Note fields in the member slice and populate them all from the rows in database. </p>\n<h2 id=\"Integration-with-context-propagation\"><a href=\"#Integration-with-context-propagation\" class=\"headerlink\" title=\"Integration with context propagation\"></a>Integration with context propagation</h2><p>Almost all web frameworks integrate with Go&#39;s context propagation system, and it is useful to take advantage of it so that when the context gets cancelled, unnecessary operations can be avoided in the backend. <a href=\"https://www.digitalocean.com/community/tutorials/how-to-use-contexts-in-go\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">This DO post</a> goes into more details about the context mechanism in go. </p>\n<p>jet makes it easier to integrate this mechanism. If we have a context instance at our disposal (likely coming as an argument in our request handler from a web framework), we can pass that to the <code>QueryContext</code> function instead of using the <code>Query</code> function as above:</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">var</span> notebooks []m.NotebookWithNotes\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">err := t.Notebook.\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    INNER_JOIN(t.Note, t.Note.NotebookID.EQ(t.Notebook.ID))\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    SELECT(t.Notebook.AllColumns).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>)).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    Query(db, &amp;notebooks)\n</td></tr></table></code></pre>\n\n<h2 id=\"Query-Logging\"><a href=\"#Query-Logging\" class=\"headerlink\" title=\"Query Logging\"></a>Query Logging</h2><p>It is clear now that jet enables us to construct complex queries dynamically in our application. It is often useful to log these queries in development so that we can see what exactly is getting executed. This is also useful for DBA audits.</p>\n<p>To make this possible, jet provides a <code>SetQueryLogger</code> API, which can be used to log operations through any logging library: </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">jet.SetQueryLogger(<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, info jet.QueryInfo)</span></span> {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tquery, args := info.Statement.Sql()\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tzerolog.Debug().\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tInt64(<span class=\"hljs-string\">&quot;DurationMS&quot;</span>, info.Duration.Milliseconds()).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tMsgf(<span class=\"hljs-string\">&quot;SQL Query: SQL: %s\\nArgs: %+v&quot;</span>, query, args)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">})\n</td></tr></table></code></pre>\n\n<p>Above example uses zerolog, but we are free to use any logging library available for go.</p>\n<h2 id=\"Insert-x2F-Update\"><a href=\"#Insert-x2F-Update\" class=\"headerlink\" title=\"Insert&#x2F;Update\"></a>Insert&#x2F;Update</h2><p>Insert&#x2F;update APIs are also pretty similar to what we&#39;d expect from SQL. We can pass raw values or make use of model structs generated for us (recommended). Following example illustrates the latter approach for insertion: </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">_, err := t.Notebook.\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tINSERT(t.Notebook.AllColumns).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tMODEL(&amp;m.Notebook{\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tTitle: &amp;title,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t}).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tExec(db)\n</td></tr></table></code></pre>\n\n<p>The wiki goes into more detail about available APIs, but it is particularly notable that jet has good support for on conflict update APIs which are often useful for preventing get-check-insert race-conditions: </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">_, err := t.Notebook.\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tINSERT(t.Notebook.AllColumns).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tMODEL(&amp;m.Notebook{\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tID:    someId,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tTitle: &amp;title,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t}).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tON_CONFLICT(t.Notebook.ID).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tDO_UPDATE(jet.SET(t.Notebook.Title.SET(t.Notebook.EXCLUDED.Title))).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tExec(db)\n</td></tr></table></code></pre>\n\n<p>In contrast, if did a select to check whether a notebook exists, and issued an insert if it didn&#39;t, the insert could still fail because a notebook could have been inserted in the meanwhile.</p>\n<h2 id=\"Subqueries\"><a href=\"#Subqueries\" class=\"headerlink\" title=\"Subqueries\"></a>Subqueries</h2><p>As we may expect by now, jet has good support for subqueries too. </p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">_, err = t.Note.DELETE().\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tWHERE(\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tt.Note.ID.IN(\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\t\tt.Note.LEFT_JOIN(t.NoteFile, t.NoteFile.NoteID.EQ(t.Note.ID)).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\t\t\tSELECT(t.Note.ID).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\t\t\tWHERE(t.Note.NotebookID.EQ(jet.String(notebookId)).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\t\t\t\tAND(t.NoteFile.ID.IS_NULL())),\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\t),\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t).\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tExecContext(ctx, store.db)\n</td></tr></table></code></pre>\n\n<p>Hopefully this provides a high-level overview that can jumpstart your go project that needs database access.</p>\n<p>This post has, however, just scratched the surface of what is possible with jet, and the aforementioned <a href=\"https://github.com/go-jet/jet/wiki\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">jet wiki</a> goes into a lot more detail.</p>\n",
            "tags": [
                "go",
                "golang",
                "jet",
                "sql"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/09/01/setting-up-log-rotation-for-zerolog/",
            "url": "https://lorefnon.me/2022/09/01/setting-up-log-rotation-for-zerolog/",
            "title": "Setting up log-rotation for zerolog",
            "date_published": "2022-09-01T00:00:00.000Z",
            "content_html": "<p><a href=\"https://github.com/rs/zerolog\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Zerolog</a> is a popular structured logging library for go. This post is a quick recipie for configuring it to use log rotation. </p>\n<p>Log rotation is a mechanism where instead of having a single log file which keeps growing forever, the application switches to a new log file when a time threshold or a size threshold is exceeded. Optionally files which are too old to be of significance can be deleted.</p>\n<p>Now a days, it is a more common practice to log to a stream and have an external service manage it for you. This is indeed nice if you can embrace it. However, Log rotation can be useful for desktop applications or isolated deployments.</p>\n<p><a href=\"https://github.com/natefinch/lumberjack\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Lumberjack</a> is a nice utility for go that supports log rotation. It is also easy to hook up with zerolog because a lumberjack logger implements io.Writer which zerolog can target.</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-comment\">/** Configuration options for log rotation */</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">type</span> LoggerConfig <span class=\"hljs-keyword\">struct</span> {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">/** Max size of the logfile before it&#x27;s rolled */</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tMaxSizeMB <span class=\"hljs-type\">int</span> <span class=\"hljs-string\">`json:&quot;max_size_mb,omitempty&quot;`</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">/** Max number of rolled files to keep */</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tMaxBackupCount <span class=\"hljs-type\">int</span> <span class=\"hljs-string\">`json:&quot;max_backup_count,omitempty&quot;`</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">/** Max age in days to keep a logfile */</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tMaxAgeDays <span class=\"hljs-type\">int</span> <span class=\"hljs-string\">`json:&quot;max_age_days,omitempty&quot;`</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">initLogger</span><span class=\"hljs-params\">(config *config.LoggerConfig)</span></span> *zerolog.Logger {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">var</span> writers []io.Writer\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">// Optional: Log to console</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\twriters = <span class=\"hljs-built_in\">append</span>(writers, zerolog.ConsoleWriter{Out: os.Stderr})\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">// Log to rolling file</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\twriters = <span class=\"hljs-built_in\">append</span>(writers, initRollingFileLogger(config))\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-comment\">// Multiwriter encapsulates multiple writers</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tmw := io.MultiWriter(writers...)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tlogger := zerolog.New(mw).With().\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tTimestamp().\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tLogger()\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> &amp;logger\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">initRollingFileLogger</span><span class=\"hljs-params\">(config *config.LoggerConfig)</span></span> *lumberjack.Logger {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tloggerPath := filepath.Join(xdg.DataHome, <span class=\"hljs-string\">&quot;example&quot;</span>, <span class=\"hljs-string\">&quot;app.log&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tfmt.Printf(<span class=\"hljs-string\">&quot;logging to file: %s\\n&quot;</span>, loggerPath)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">return</span> &amp;lumberjack.Logger{\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tFilename:   loggerPath,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tMaxBackups: config.MaxBackupCount,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tMaxSize:    config.MaxSizeMB,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tMaxAge:     config.MaxAgeDays,\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr></table></code></pre>\n\n<p>We can now use the logger returned by initLogger to write logs, and they will be written to a file which will be rotated by lumberjack.</p>\n",
            "tags": [
                "go",
                "golang",
                "zerolog"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/06/25/generating-api-docs-for-zod-types/",
            "url": "https://lorefnon.me/2022/06/25/generating-api-docs-for-zod-types/",
            "title": "Generating API docs for zod-types",
            "date_published": "2022-06-25T00:00:00.000Z",
            "content_html": "<p>I often like to use <a href=\"https://github.com/colinhacks/zod\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a> for validating user provided options in the public API in typescript projects. Zod offers a really nice validation &amp; type inference support and it is nice to be able to fail early for invalid options even if consumer is not using typescript.</p>\n<p>Generating API documentation is a bit of trouble though, for these types. <a href=\"https://typedoc.org/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Typedoc</a> is a nice documentation generator I frequently use, but it does not have any specialized zod support and works best when types are defined through normal typescript interfaces.</p>\n<p>So what do we do ? </p>\n<p>Interestingly, typescript is able to propagate comments through inheritance hierarchy and mapped types.</p>\n<p>So if we have a zod-type as follows: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-comment\">/** Full name of user */</span>\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>()\n&#125;)</code></pre>\n\n<p>and later define an interface that extends the type inferred from this: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-title class_\">TypeOf</span>&lt;typeof <span class=\"hljs-title class_\">UserSchema</span>&gt; &#123;&#125;</code></pre>\n\n<p>The generated documentation of User will contain the comments for name property.</p>\n<p>This unfortunately works only for Object types as long as we don&#39;t introduce any unions and intersections - any base type of an interface must have statically known members. This also doesn&#39;t work well for nested object types as typedoc will pick only the types at top level.</p>\n<p>For more complex types, a simple workaround is to extract interfaces for constituent types and link them in the documentation. </p>\n<p>So instead of:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserDetailsSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">profile</span>: z.<span class=\"hljs-title function_\">object</span>(&#123;\n        <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>()\n    &#125;).<span class=\"hljs-title function_\">nullish</span>()\n&#125;);</code></pre>\n\n<p>We&#39;d write: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ProfileSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-comment\">/** Full name of user */</span>\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>()\n&#125;);\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Profile</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-title class_\">TypeOf</span>&lt;typeof <span class=\"hljs-title class_\">ProfileSchema</span>&gt; &#123;&#125;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserDetailsSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-comment\">/** See &#123;<span class=\"hljs-doctag\">@link</span> Profile&#125; */</span>\n    <span class=\"hljs-attr\">profile</span>: <span class=\"hljs-title class_\">Profile</span>.<span class=\"hljs-title function_\">nullish</span>()\n&#125;)\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserDetails</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-title class_\">TypeOf</span>&lt;typeof <span class=\"hljs-title class_\">UserDetailsSchema</span>&gt; &#123;&#125;</code></pre>\n\n<p>This increases the boilerplate a bit, but is otherwise quite practical.</p>\n",
            "tags": [
                "typescript",
                "zod"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/06/18/type-safe-event-handling-with-zod-and-ts-pattern/",
            "url": "https://lorefnon.me/2022/06/18/type-safe-event-handling-with-zod-and-ts-pattern/",
            "title": "Type-safe event handling in Typescript with zod and ts-pattern",
            "date_published": "2022-06-18T00:00:00.000Z",
            "content_html": "<h1 id=\"Event-handling\"><a href=\"#Event-handling\" class=\"headerlink\" title=\"Event handling\"></a>Event handling</h1><p>It is no surprise to anyone that event handling is bread and butter in javascript. However, often we receive several types of events from an event source which makes handling them in a type-safe manner harder. Eg. if we are consuming websocket events on the backend we may write something like: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> ws <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ws&quot;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>()\n\n<span class=\"hljs-keyword\">const</span> server = app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>)\n\n<span class=\"hljs-keyword\">const</span> wss = <span class=\"hljs-keyword\">new</span> ws.<span class=\"hljs-title class_\">Server</span>(&#123; server &#125;)\n\nwss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;connection&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ws: ws.WebSocket</span>) =&gt;</span> &#123;\n    ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data); \n               ^\n               <span class=\"hljs-string\">`----- any :(</span>\n<span class=\"hljs-string\">    &#125;)</span>\n<span class=\"hljs-string\">&#125;)</span></code></pre>\n\n<p>Similarly we could be receiving a message from a different window&#x2F;frame through postMessage, or another peer over a webrtc data channel, the problem remains the same: After receiving the data we need to disambiguate it into one of the multiple possible types of messages and branch out the handling logic from there.</p>\n<p>The most basic way would be to write a <a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">type-guard</a> for each possible type.</p>\n<p>Typescript offers flow-sensitive typing so once we have established in a branch that a value is of a particular type, we do need any extra casts. </p>\n<p>So we could write something like this: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">PostDetails</span> &#123;\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-comment\">// Types for our events:</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">CreatePost</span> &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;CreatePost&quot;</span>,\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetails</span>\n&#125;\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UpdatePost</span> &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>,\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetails</span>\n&#125;\n\n<span class=\"hljs-comment\">// Type-guards for different message types</span>\n<span class=\"hljs-keyword\">const</span> isCreatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt; event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;CreatePost&quot;</span>\n<span class=\"hljs-keyword\">const</span> isUpdatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt; event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>\n\n<span class=\"hljs-comment\">// Later in our message receiver: </span>\n\nws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data); \n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isCreatePost</span>(parsed)) &#123;\n        ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleCreatePost</span>(parsed))\n        <span class=\"hljs-comment\">//                       ^</span>\n        <span class=\"hljs-comment\">//                       `---- type of parsed is CreatePost in this branch</span>\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isUpdatePost</span>(parsed)) &#123;\n        ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleUpdatePost</span>(parsed))\n        <span class=\"hljs-comment\">//                        ^</span>\n        <span class=\"hljs-comment\">//                         `---- type of parsed is UpdatePost in this branch</span>\n    &#125;\n    <span class=\"hljs-comment\">// ....</span>\n&#125;)</code></pre>\n\n<p>This works, but it is quite a bit of boilerplate to discriminate&#x2F;disambiguate between different possible types. This boilerpate is also repetitive if we adopt a convention that we will always discriminate the types based on a <code>type</code> attribute which all the events will have. </p>\n<p>Other issue is that we are trusting the rest of the shape of the data based on the type attribute. Our type-guards (isCreatePost, isUpdatePost etc.) just check for the type property - and assumes that rest of the properties are as expected. If the websocket client sends an invalid object like <code>&#123; type: &quot;CreatePost&quot; &#125;</code> (no data) we will get a runtime error which may surface deeper inside the handling logic with a confusing stack trace. </p>\n<p>When we are receiving data over a network boundary or from a persisted store, it is generally safer to validate the complete payload at the boundary itself (which is our message receiver function in this example) and fail early with a clean error.</p>\n<p>We could write our type-guard to be more defensive like: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> isCreatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt; &#123;\n    <span class=\"hljs-keyword\">return</span> event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;CreatePost&quot;</span> &amp;&amp;\n        <span class=\"hljs-keyword\">typeof</span> event.<span class=\"hljs-property\">data</span> === <span class=\"hljs-string\">&quot;object&quot;</span> &amp;&amp;\n        <span class=\"hljs-keyword\">typeof</span> event.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">title</span> === <span class=\"hljs-string\">&quot;string&quot;</span> &amp;&amp;\n        <span class=\"hljs-keyword\">typeof</span> event.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">description</span> === <span class=\"hljs-string\">&quot;string&quot;</span>;\n&#125;</code></pre>\n\n<p>But this is now a ton of additional work. </p>\n<p>This is also error prone because tomorrow if we add another field in PostDetails we will also need to update all these type-guards to accomodate the same. They have to kept in sync manually with no help from type-checker whatsoever.</p>\n<p>Fortunately, we have libraries to simplify this validation logic for us. One such library is <a href=\"https://github.com/colinhacks/zod\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a> which is what I currently use in my production applications.</p>\n<p>With zod we can define the shape of our events through zod&#39;s API: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> zod <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">PostDetailsSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">title</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">description</span>: z.<span class=\"hljs-title function_\">string</span>()\n&#125;);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">CreatePostSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;CreatePost&quot;</span>),\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n&#125;);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UpdatePostSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;UpdatePost&quot;</span>),\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>.<span class=\"hljs-title function_\">partial</span>()\n&#125;)</code></pre>\n\n<p>The benefit of defining these schema objects, is that we are able to perform runtime validation of unknown data.</p>\n<p>So our isCreatePost type-guard can be written as: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> isCreatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt;\n    <span class=\"hljs-title class_\">CreatePostSchema</span>.<span class=\"hljs-title function_\">safeParse</span>(event).<span class=\"hljs-property\">success</span></code></pre>\n\n<p>We also don&#39;t have to manually define the typescript interfaces for <code>CreatePost</code>, <code>UpdatePost</code> etc. ourselves. They can instead be inferred from the Schema objects. </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">CreatePost</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">CreatePostSchema</span>&gt;;\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">UpdatePost</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">UpdatePostSchema</span>&gt;;</code></pre>\n\n<p>The above approach of discriminating between multiple types using a shared property is very common in practice, and we call union of such types as discriminated unions. </p>\n<p>Zod has built in support for discriminated unions, and we can define an EventSchema as follows: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">//                                          ,---- Property based on which we will discriminate</span>\n<span class=\"hljs-comment\">//                                         V           the members of our union type</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EventSchema</span> = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(<span class=\"hljs-string\">&quot;type&quot;</span>, [\n    <span class=\"hljs-title class_\">CreatePostSchema</span>,\n    <span class=\"hljs-title class_\">UpdatePostSchema</span>\n])</code></pre>\n\n<p>Often, we won&#39;t define the individual members separately: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EventSchema</span> = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(<span class=\"hljs-string\">&quot;type&quot;</span>, [\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;CreatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n   &#125;),\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;UpdatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n   &#125;)\n])</code></pre>\n\n<p>which is exactly the same as above. </p>\n<p>If we use the previously mentioned TypeOf type to get the static type of EventSchema we will get a union of the CreatePost and UpdatePost types. </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Event</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">EventSchema</span>&gt;</code></pre>\n\n<p>The above will be inferred as: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Event</span> = \n    | &#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;CreatePost&quot;</span>, <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span> &#125; &#125;\n    | &#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>, <span class=\"hljs-attr\">data</span>: &#123; title?: <span class=\"hljs-built_in\">string</span>, description?: <span class=\"hljs-built_in\">string</span> &#125; &#125;</code></pre>\n\n<p>which is effectively: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Event</span> = <span class=\"hljs-title class_\">CreatePost</span> | <span class=\"hljs-title class_\">UpdatePost</span></code></pre>\n\n<p>One additional thing that we gain from defining a discriminated union is an exhaustiveness check. So we if we use <code>EventSchema.parse(someData)</code> this will throw a runtime error if someData does not conform to the complete shape of one of the errors.</p>\n<p>We can write our handler as: </p>\n<pre><code class=\"hljs ts\">ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">try</span> &#123; \n        <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title class_\">EventSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data)); <span class=\"hljs-comment\">// Parse will throw for invalid events</span>\n        <span class=\"hljs-comment\">//     ^</span>\n        <span class=\"hljs-comment\">//      `--- CreatePost | UpdatePost</span>\n        <span class=\"hljs-keyword\">switch</span> (parsed.<span class=\"hljs-property\">type</span>) &#123;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;CreatePost&quot;</span>:\n            ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleCreatePost</span>(parsed)) \n            <span class=\"hljs-comment\">//                        ^</span>\n            <span class=\"hljs-comment\">//                        `---- type of parsed is CreatePost in this branch</span>\n            <span class=\"hljs-keyword\">return</span>; \n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>:\n            ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleUpdatePost</span>(parsed))\n            <span class=\"hljs-comment\">//                      ^</span>\n            <span class=\"hljs-comment\">//                       `---- type of parsed is UpdatePost in this branch</span>\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n        <span class=\"hljs-comment\">// Also see https://github.com/colinhacks/zod#error-formatting</span>\n    &#125;\n&#125;)\n</code></pre>\n\n<p>However, it would be also nice to have this exhaustiveness check enforced in our handler at compile time. The way our code is currently written, tomorrow if we add a new type of event in the discriminated union, but forget to add an if-else branch in the above code, it will get silently ignored - Not great. </p>\n<p>We can take advantage of the typescript compiler option <a href=\"https://www.typescriptlang.org/tsconfig#noImplicitReturns\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">noImplicitReturns</a> to enforce this: </p>\n<pre><code class=\"hljs ts\">ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">try</span> &#123; \n        ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleEvent</span>(<span class=\"hljs-title class_\">EventSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data)))); <span class=\"hljs-comment\">// Parse will throw for invalid events</span>\n    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n    &#125;\n&#125;);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleEvent</span> = (<span class=\"hljs-params\">event: Event</span>) =&gt; &#123;\n    <span class=\"hljs-keyword\">switch</span> (event.<span class=\"hljs-property\">type</span>) &#123;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;CreatePost&quot;</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">handleCreatePost</span>(event);\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">handleUpdatePost</span>(event);\n    &#125;\n&#125;</code></pre>\n\n<p>Note that our switch statement does not have a default case. </p>\n<p>So if we update our Event have another variant like: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EventSchema</span> = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(<span class=\"hljs-string\">&quot;type&quot;</span>, [\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;CreatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n   &#125;),\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;UpdatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>.<span class=\"hljs-title function_\">partial</span>()\n   &#125;),\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;DeletePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: z.<span class=\"hljs-title function_\">object</span>(&#123; <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>() &#125;)\n   &#125;)\n])</code></pre>\n\n<p>None of the switch-case branches will now match for <code>DeletePost</code> and we will end up with a possible branch of code that returns implicitly. Typescript will now complain about that.</p>\n<p>We could wrap-up the post here - given that we have accomplished all the type-safety features we wanted. However, I am not a huge fan of having to rely on implicit returns (or similar workarounds) for exhaustiveness check. </p>\n<p>In many functional languages, we have support for <a href=\"https://abitofocaml.weebly.com/12-pattern-matching.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">pattern-matching</a> with built in support for exhaustiveness check. Typescript does not have this at the moment but there are userland implementations that emulate pattern matching. One such library is <a href=\"https://github.com/gvergnaud/ts-pattern\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">ts-pattern</a>, which I have found to work very well in practice. </p>\n<p>With ts-pattern we could write our handler as: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; match &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-pattern&quot;</span>;\n\n<span class=\"hljs-comment\">// --- </span>\n\n<span class=\"hljs-title function_\">match</span>(event)\n    .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;CreatePost&#x27;</span> &#125;, handleCreatePost)\n    .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;UpdatePost&#x27;</span> &#125;, handleUpdatePost)\n    .<span class=\"hljs-title function_\">exhaustive</span>()   <span class=\"hljs-comment\">// &lt;--- will be a type error if Event type has any other union members</span></code></pre>\n\n<p>Not only is this more succinct for this use case, ts-pattern becomes more useful when we have more complex scenario like combining multiple predicates or performing checks based on multiple properties. Take a look at some of their examples in the <a href=\"https://github.com/gvergnaud/ts-pattern#readme\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">docs</a>.</p>\n<p>Also, unlike our switch-case or if-else examples above, the entire match invocation is a single expression so we could use the return value of our handler without needing temporary variables.</p>\n<pre><code class=\"hljs ts\">ws.<span class=\"hljs-title function_\">send</span>(\n    <span class=\"hljs-title function_\">match</span>(event)\n        .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;CreatePost&#x27;</span> &#125;, handleCreatePost)\n        .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;UpdatePost&#x27;</span> &#125;, handleUpdatePost)\n        .<span class=\"hljs-title function_\">exhaustive</span>()\n)</code></pre>\n\n<p>Cool, eh ?</p>\n",
            "tags": [
                "typescript",
                "zod",
                "ts-pattern"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/06/18/type-safe-jsonb-with-ts-sql-query/",
            "url": "https://lorefnon.me/2022/06/18/type-safe-jsonb-with-ts-sql-query/",
            "title": "Making jsonb access type-safe with a zod adapter in ts-sql-query",
            "date_published": "2022-06-18T00:00:00.000Z",
            "content_html": "<p><a href=\"https://ts-sql-query.readthedocs.io/en/stable\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">ts-sql-query</a> is a nice typescript library for typesafe database access. It goes to great lengths to ensure that if code compiles without type errors then all generated SQL is correct. Of course there are escape hatches for advanced scenarios, but having type-safety for the 90% most common usages is a huge productivity boost.</p>\n<p>Modern databases like postgres have built in json support, enabling us to store semi-structured data in a database column. While this does go against norms of traditional normalization, in practice it is immensely convenient for cases where shaping the data into tabular format is either very time consuming or simply not feasible because the entire structure of data is not known ahead of time or changes frequently.</p>\n<p>However, to be able to effectively process this data in application layer, it is often beneficial to have an application-side schema to validate this json data even if this schema is not 100% known ahead of time, evolves alongside our understanding of data or not 100% strict.</p>\n<p>In typescript, we have a multitude of options for schema validation like <a href=\"https://zod.dev/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a>, <a href=\"https://github.com/gcanti/io-ts\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">io-ts</a>, <a href=\"https://joi.dev/api/?v=17.6.0\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">joi</a> etc. In this post we primarily focus on zod because IMHO it strikes a very good balance between a user friendly API, available features and being able to extract static types from schema definitions.</p>\n<p>Whiel ts-sql-query does not have json support built-in, it supports custom types through <a href=\"https://ts-sql-query.readthedocs.io/en/stable/supported-operations/#type-adpaters\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">TypeAdapter</a>. So for our jsonb columns we can write a TypeAdapter that utilizes zod to enforce that the data coming from and going to the database conforms to our expectations.</p>\n<p>Let&#39;s say we have a zod type ChapterMedatadata:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">array</span>(),\n&#125;);\n\n<span class=\"hljs-comment\">// Extract static type</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ChapterMetadata</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>&gt;;</code></pre>\n\n<p>Following would be a type adapter that validates the incoming and outgoing json through this type:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">DefaultTypeAdapter</span>, <span class=\"hljs-title class_\">TypeAdapter</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-sql-query/TypeAdapter&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>: <span class=\"hljs-title class_\">TypeAdapter</span> = &#123;\n    <span class=\"hljs-title function_\">transformValueFromDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-comment\">// Our database adapter (postgres) is aware of jsonb and has already</span>\n            <span class=\"hljs-comment\">// parsed the JSON. So we don&#x27;t need JSON.parse. However if the dabase</span>\n            <span class=\"hljs-comment\">// didn&#x27;t have first class support for json type and</span>\n            <span class=\"hljs-comment\">// we were storing the JSON in a text field we would need to do a JSON.parse first</span>\n            <span class=\"hljs-comment\">// before calling ChapterMetadataSchema.parse</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n\n        <span class=\"hljs-comment\">// If type is not jsonb then gracefully fallback to the next adapter</span>\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueFromDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n\n    <span class=\"hljs-title function_\">transformValueToDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-comment\">// This is strictly not necessary because TS will ensure</span>\n            <span class=\"hljs-comment\">// that atleast the static type is enforced.</span>\n            <span class=\"hljs-comment\">//</span>\n            <span class=\"hljs-comment\">// However it offers aditional safety if we have some refinements</span>\n            <span class=\"hljs-comment\">// or if there is possibility of values with any type creeping in.</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n\n        <span class=\"hljs-comment\">// If type is not jsonb gracefully fallback to the next adapter</span>\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueToDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n&#125;;</code></pre>\n\n<p>Once we have the adapter in place, we can use this in our table mapping:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Table</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-sql-query/Table&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChaptersTable</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Table</span>&lt;<span class=\"hljs-title class_\">DBConnection</span>, <span class=\"hljs-string\">&quot;ChaptersTable&quot;</span>&gt; &#123;\n    id = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">autogeneratedPrimaryKey</span>(<span class=\"hljs-string\">&quot;id&quot;</span>, <span class=\"hljs-string\">&quot;int&quot;</span>);\n    metadata = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">optionalColumn</span>&lt;<span class=\"hljs-title class_\">ChapterMetadata</span>&gt;(\n        <span class=\"hljs-string\">&quot;metadata&quot;</span>,\n        <span class=\"hljs-string\">&quot;custom&quot;</span>,\n        <span class=\"hljs-string\">&quot;jsonb&quot;</span>,\n        <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>\n    );\n\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;\n        <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-string\">&quot;chapters&quot;</span>);\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> tChapters = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChaptersTable</span>();</code></pre>\n\n<p>So now whenever we try to retrieve the data from database, the value for metadata column will be validated against our schema.</p>\n<p>And because we have passed the ChapterMetadata static type as a type parameter to the column, for operations performed in typescript codebase, we get static type safety as well:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-title function_\">getConnection</span>()\n    .<span class=\"hljs-title function_\">insertInto</span>(tChapters)\n    .<span class=\"hljs-title function_\">set</span>(&#123; <span class=\"hljs-attr\">metadata</span>: &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Test&quot;</span>, <span class=\"hljs-attr\">topic</span>: <span class=\"hljs-string\">&quot;test&quot;</span> &#125; &#125;); <span class=\"hljs-comment\">// &lt;-- Static type error</span></code></pre>\n\n<p>Note that whenever we are performing type validation of data coming from a long term storage, we need to be cautious with schema evolution.</p>\n<p>Tomorrow if we update the type and add backward incompatible changes (eg. new mandatory fields), then the rows containing past data can become inaccessible.</p>\n<p>So it is better to ensure that any schema change is additive, and new fields added are optional. It is also useful to perform two step transitions where in the transition duration the schema is compatible with both previous and new shape of data (at the cost of being more relaxed than is necessary).</p>\n<p>Lastly, the above type adapter assumes that the shape of data as stored in database matches the shape of the data that the application deals with.</p>\n<p>It can sometimes be desirable to store the data in a different format than what the application deals. This could be either to facilitate ease of indexing or compaction of storage on the db side, or to use more complex data structures than json-compatible objects and arrays on the application side.</p>\n<p>While zod does not support codecs like some other libraries like io-ts, it is possible to use two different (mutually compatible) types in transformValueToDB and transformValueFromDB to convert between the two representations.</p>\n<p>A simple example of two such types can be:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z\n        .<span class=\"hljs-title function_\">string</span>()\n        .<span class=\"hljs-title function_\">array</span>()\n        .<span class=\"hljs-title function_\">transform</span>(\n            <span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n                <span class=\"hljs-comment\">// Convert the JSON array to a Set</span>\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(it)\n        ),\n    <span class=\"hljs-attr\">relevanceScores</span>: z.<span class=\"hljs-title function_\">record</span>(z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">transform</span>(\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n            <span class=\"hljs-comment\">// Convert the JSON object to a Map</span>\n            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(it))\n    ),\n&#125;);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z.<span class=\"hljs-title function_\">set</span>(z.<span class=\"hljs-title function_\">string</span>()).<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n        <span class=\"hljs-comment\">// Convert set to array</span>\n        [...it]\n    ),\n    <span class=\"hljs-attr\">relevanceScores</span>: z.<span class=\"hljs-title function_\">map</span>(z.<span class=\"hljs-title function_\">string</span>(), z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n        <span class=\"hljs-comment\">// Convert Map to object</span>\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(it.<span class=\"hljs-title function_\">entries</span>())\n    ),\n&#125;);</code></pre>\n\n<p>Now we can change our adapter to use these two separate types:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>: <span class=\"hljs-title class_\">TypeAdapter</span> = &#123;\n    <span class=\"hljs-title function_\">transformValueFromDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueFromDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n\n    <span class=\"hljs-title function_\">transformValueToDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueToDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n&#125;;</code></pre>\n\n<p>We need to make sure that these two types are always mutually compatible ie. for any valid values</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>.<span class=\"hljs-title function_\">parse</span>(value));</code></pre>\n\n<p>succeeds, and vice versa.</p>\n<p>We can use unit tests to ensure that, and we can also add witness types to validate the compatibility of corresponding static types.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Type that enforces that U is assignable to T</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ExtendsWitness</span>&lt;U <span class=\"hljs-keyword\">extends</span> T, T&gt; = U;\n\n<span class=\"hljs-comment\">// If the Input type of ChapterMetadataAppToDBSchema is not compatbile with</span>\n<span class=\"hljs-comment\">// output type of ChapterMetadataDBToAppSchema following witness will have a type error</span>\n<span class=\"hljs-keyword\">type</span> _ChapterMetadataWitness1 = <span class=\"hljs-title class_\">ExtendsWitness</span>&lt;\n    z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>&gt;,\n    <span class=\"hljs-comment\">// Extract input type from ChapterMetadataAppToDBSchema</span>\n    <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-property\">ZodType</span>&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>, infer <span class=\"hljs-title class_\">TIn</span>&gt;\n        ? <span class=\"hljs-title class_\">TIn</span>\n        : <span class=\"hljs-built_in\">never</span>\n&gt;;</code></pre>\n\n<p>and similarly the other way round.</p>\n",
            "tags": [
                "typescript",
                "zod",
                "ts-sql-query"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/04/26/using-jte-kotlin-templates-in-spring-boot/",
            "url": "https://lorefnon.me/2022/04/26/using-jte-kotlin-templates-in-spring-boot/",
            "title": "Using jte kotlin templates in spring-boot",
            "date_published": "2022-04-26T00:00:00.000Z",
            "content_html": "<h1 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h1><p><a href=\"https://github.com/casid/jte\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">jte</a> is a new and performant template engine for JVM.\nIt supports precompilation of templates in production and hot reloading in development, and also has good tooling support though an intellij plugin.</p>\n<p>jte has recently introduced support for kotlin templates - where the embedded expressions are kotlin instead of java.\nThis is a natural fit if your backend is implemented in kotlin and this post is a quick recipe for configuring this in spring-boot.</p>\n<p>jte already provides a spring-boot-starter which takes care of all of the plumbing. We just need to add the jte-kotlin dependency for kotlin template support.</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">// In build.gradle.kts</span>\n\ndependencies &#123;\n\t<span class=\"hljs-keyword\">var</span> jteVersion = <span class=\"hljs-string\">&quot;2.0.2&quot;</span>\n\n\timplementation(<span class=\"hljs-string\">&quot;gg.jte:jte-spring-boot-starter:<span class=\"hljs-variable\">$jteVersion</span>&quot;</span>)\n        <span class=\"hljs-comment\">// jte-kotlin is needed to compile kte templates</span>\n\timplementation(<span class=\"hljs-string\">&quot;gg.jte:jte-kotlin:<span class=\"hljs-variable\">$jteVersion</span>&quot;</span>)\n\n        <span class=\"hljs-comment\">// ... other dependencies</span>\n&#125;</code></pre>\n\n<p>As an additional convenience we configure the view resolver below to automatically pick kte templates (with embedded kotlin expressions)\nwhen no template extension is provided:</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">package</span> com.example.config\n\n<span class=\"hljs-keyword\">import</span> gg.jte.TemplateEngine\n<span class=\"hljs-keyword\">import</span> gg.jte.springframework.boot.autoconfigure.JteViewResolver\n<span class=\"hljs-keyword\">import</span> org.springframework.context.<span class=\"hljs-keyword\">annotation</span>.Bean\n<span class=\"hljs-keyword\">import</span> org.springframework.context.<span class=\"hljs-keyword\">annotation</span>.Configuration\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TemplateConfig</span> &#123;\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">jteViewResolver</span><span class=\"hljs-params\">(templateEngine: <span class=\"hljs-type\">TemplateEngine</span>)</span></span> =\n        JteViewResolver(templateEngine).apply &#123;\n            setSuffix(<span class=\"hljs-string\">&quot;.kte&quot;</span>)\n        &#125;\n&#125;</code></pre>\n\n<p>Now, if we have a controller like this:</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">package</span> com.kaljourn.server.controller\n\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Controller\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.<span class=\"hljs-keyword\">annotation</span>.GetMapping\n\n<span class=\"hljs-meta\">@Controller</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeController</span> &#123;\n    <span class=\"hljs-meta\">@GetMapping(<span class=\"hljs-string\">&quot;/&quot;</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">home</span><span class=\"hljs-params\">()</span></span>: String = <span class=\"hljs-string\">&quot;home/index&quot;</span>\n&#125;</code></pre>\n\n<p>Now, the template file at <code>src/main/jte/home/index.kte</code> will be automatically picked up and rendered whenever user visits the <code>/</code> endpoint.</p>\n",
            "tags": [
                "kotlin",
                "spring-boot"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/03/13/configuring-spring-security-to-use-komapper/",
            "url": "https://lorefnon.me/2022/03/13/configuring-spring-security-to-use-komapper/",
            "title": "Configuring spring security to use komapper",
            "date_published": "2022-03-13T00:00:00.000Z",
            "content_html": "<h1 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h1><p><a href=\"https://spring.io/projects/spring-security\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Spring security</a> is a versatile and popular authentication solution for the JVM ecosystem. It is an officially supported component of spring ecosystem and widely deployed in many production solutions.</p>\n<p><a href=\"https://www.komapper.org/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">KOMapper</a> is a new ORM for Kotlin that embraces KSP.</p>\n<p>Because spring-security is, at its core, agnostic of any specific persistence solution (even spring-data is not mandatory), we can easily configure it to use komapper for authenticating users.</p>\n<h1 id=\"Bootstrapping-the-application\"><a href=\"#Bootstrapping-the-application\" class=\"headerlink\" title=\"Bootstrapping the application\"></a>Bootstrapping the application</h1><p>We can download a scaffolded project from the <a href=\"https://start.spring.io/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">https://start.spring.io</a> after selecting spring-boot-starter-jdbc, spring-boot-starter-web and spring-boot-starter-security.</p>\n<p>While in this post we use JDBC and spring-web, both komapper and spring-security also work with r2dbc &amp; spring webflux.</p>\n<p>Our final build.gradle.kts file will look something like this:</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">plugins {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tid(<span class=\"hljs-string\">&quot;org.springframework.boot&quot;</span>) version <span class=\"hljs-string\">&quot;2.6.4&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tid(<span class=\"hljs-string\">&quot;io.spring.dependency-management&quot;</span>) version <span class=\"hljs-string\">&quot;1.0.11.RELEASE&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tkotlin(<span class=\"hljs-string\">&quot;jvm&quot;</span>) version <span class=\"hljs-string\">&quot;1.6.10&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tkotlin(<span class=\"hljs-string\">&quot;plugin.spring&quot;</span>) version <span class=\"hljs-string\">&quot;1.6.10&quot;</span>\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tid(<span class=\"hljs-string\">&quot;com.google.devtools.ksp&quot;</span>) version <span class=\"hljs-string\">&quot;1.6.10-1.0.4&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">kotlin {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tsourceSets.main {\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">        <span class=\"hljs-comment\">// This directory contains the source files generated by</span>\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">        <span class=\"hljs-comment\">// Komapper&#x27;s KSP processor</span>\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tkotlin.srcDir(<span class=\"hljs-string\">&quot;build/generated/ksp/main/kotlin&quot;</span>)\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none\" class=\"hlcode-fold-collapsed\" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" colspan=\"1\"><div class=\"hlcode-fold-handle\" data-fold-id=\"hlcode-fold-20\"><svg height=\"21\" viewBox=\"0 0 21 21\" width=\"21\" xmlns=\"http://www.w3.org/2000/svg\">\n        <g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" transform=\"translate(4 4)\">\n            <path d=\"m10.5.5h-8c-1.1045695 0-2 .8954305-2 2v8c0 1.1045695.8954305 2 2 2h8c1.1045695 0 2-.8954305 2-2v-8c0-1.1045695-.8954305-2-2-2z\" transform=\"matrix(0 1 -1 0 13 0)\"/>\n            <path d=\"m6.5 3.5v6.056\"/>\n            <path d=\"m6.5 3.5v6\" transform=\"matrix(0 1 -1 0 13 0)\"/>\n        </g>\n    </svg><span class=\"hlcode-fold-text\">7 lines collapsed</span></div></td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">group = <span class=\"hljs-string\">&quot;com.test&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">version = <span class=\"hljs-string\">&quot;0.0.1-SNAPSHOT&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">java.sourceCompatibility = JavaVersion.VERSION_16\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">repositories {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\tmaven { url = uri(<span class=\"hljs-string\">&quot;https://repo.spring.io/release&quot;</span>) }\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\tmavenCentral()\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">dependencies {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\t<span class=\"hljs-keyword\">val</span> komapperVersion = <span class=\"hljs-string\">&quot;0.30.0&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-starter-actuator&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-starter-jdbc&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-starter-jersey&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-starter-security&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.komapper:komapper-spring-boot-starter-jdbc:<span class=\"hljs-variable\">$komapperVersion</span>&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.komapper:komapper-dialect-h2-jdbc:<span class=\"hljs-variable\">$komapperVersion</span>&quot;</span>)\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-comment\">// We need to explicitly enable komapper&#x27;s KSP processor</span>\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tksp(<span class=\"hljs-string\">&quot;org.komapper:komapper-processor:<span class=\"hljs-variable\">$komapperVersion</span>&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.jetbrains.kotlin:kotlin-reflect&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;org.liquibase:liquibase-core&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\tdevelopmentOnly(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-devtools&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\timplementation(<span class=\"hljs-string\">&quot;com.h2database:h2&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\ttestImplementation(<span class=\"hljs-string\">&quot;org.springframework.boot:spring-boot-starter-test&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none\" class=\"hlcode-fold-collapsed\" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" colspan=\"1\"><div class=\"hlcode-fold-handle\" data-fold-id=\"hlcode-fold-20\"><svg height=\"21\" viewBox=\"0 0 21 21\" width=\"21\" xmlns=\"http://www.w3.org/2000/svg\">\n        <g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" transform=\"translate(4 4)\">\n            <path d=\"m10.5.5h-8c-1.1045695 0-2 .8954305-2 2v8c0 1.1045695.8954305 2 2 2h8c1.1045695 0 2-.8954305 2-2v-8c0-1.1045695-.8954305-2-2-2z\" transform=\"matrix(0 1 -1 0 13 0)\"/>\n            <path d=\"m6.5 3.5v6.056\"/>\n            <path d=\"m6.5 3.5v6\" transform=\"matrix(0 1 -1 0 13 0)\"/>\n        </g>\n    </svg><span class=\"hlcode-fold-text\">9 lines collapsed</span></div></td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">tasks.withType&lt;KotlinCompile&gt; {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\tkotlinOptions {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tfreeCompilerArgs = listOf(<span class=\"hljs-string\">&quot;-Xjsr305=strict&quot;</span>)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\t\tjvmTarget = <span class=\"hljs-string\">&quot;16&quot;</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\t}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">tasks.withType&lt;Test&gt; {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">\tuseJUnitPlatform()\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-20\"><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr></table></code></pre>\n\n<p>Spring-security autoconfigures the application to use a form based login screen, that looks like this:</p>\n<p><img src=\"/images/2020-03-13/spring-security-login-page.png\" alt=\"Spring security login page\" loading=\"lazy\"></p>\n<p>Before we can access any of the protected routes (all by default) we will need to authenticate.</p>\n<p>To keep this post simple, we will use <a href=\"https://h2database.com/html/main.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">h2 database</a> here - we can configure the location where our db will store data in application.properties.</p>\n<pre><code class=\"hljs plaintext\">spring.datasource.url=jdbc:h2:/tmp/db\nspring.datasource.driverClassName=org.h2.Driver\nspring.datasource.username=sa\nspring.datasource.password=\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect</code></pre>\n\n<p>Please ensure that any location chosen here is writable by the running user.</p>\n<p>We will need a user table which will store our user details. In production we should use a migration system like dbmate or liquibase. To simplify things here, we can create this table through h2-console\navailable in localhost:8080&#x2F;h2-console</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> users (\n    id <span class=\"hljs-keyword\">identity</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key,\n    name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,\n    email <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,\n    password <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)\n)</code></pre>\n\n<p>We can map this table to a Kotlin data class through the komapper provided annotations:</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">package</span> com.test.server.entity\n\n<span class=\"hljs-keyword\">import</span> org.komapper.<span class=\"hljs-keyword\">annotation</span>.*\n<span class=\"hljs-keyword\">import</span> java.time.LocalDateTime\n\n<span class=\"hljs-meta\">@KomapperEntity</span>\n<span class=\"hljs-meta\">@KomapperTable(<span class=\"hljs-string\">&quot;users&quot;</span>)</span>\n<span class=\"hljs-keyword\">data</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> (\n    <span class=\"hljs-meta\">@KomapperId</span>\n    <span class=\"hljs-meta\">@KomapperAutoIncrement</span>\n    <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-built_in\">Int</span>,\n\n    <span class=\"hljs-keyword\">var</span> name: String,\n\n    <span class=\"hljs-keyword\">var</span> email: String,\n\n    <span class=\"hljs-keyword\">var</span> password: String,\n)</code></pre>\n\n<p>In ideal setup, we will also keep track of whether the email has been validated, how many times auth attempts have been successful, whether password meets expected strength etc. But in this article we will focus on just validating the user provided password against the value stored in database.</p>\n<p>spring-security will, by default, find and delegate to a UserDetailsService implementation in the application context. So we will need to provide an UserDetailsService implementation that uses komapper.</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">package</span> com.test.server.service\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none\" class=\"hlcode-fold-collapsed\" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" colspan=\"1\"><div class=\"hlcode-fold-handle\" data-fold-id=\"hlcode-fold-21\"><svg height=\"21\" viewBox=\"0 0 21 21\" width=\"21\" xmlns=\"http://www.w3.org/2000/svg\">\n        <g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" transform=\"translate(4 4)\">\n            <path d=\"m10.5.5h-8c-1.1045695 0-2 .8954305-2 2v8c0 1.1045695.8954305 2 2 2h8c1.1045695 0 2-.8954305 2-2v-8c0-1.1045695-.8954305-2-2-2z\" transform=\"matrix(0 1 -1 0 13 0)\"/>\n            <path d=\"m6.5 3.5v6.056\"/>\n            <path d=\"m6.5 3.5v6\" transform=\"matrix(0 1 -1 0 13 0)\"/>\n        </g>\n    </svg><span class=\"hlcode-fold-text\">9 lines collapsed</span></div></td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> com.test.server.entity.User\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> com.test.server.entity.user\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.komapper.core.dsl.Meta\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.komapper.core.dsl.QueryDsl\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.komapper.core.dsl.query.first\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.komapper.jdbc.JdbcDatabase\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.springframework.security.core.GrantedAuthority\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.springframework.security.core.userdetails.UserDetails\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.springframework.security.core.userdetails.UserDetailsService\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line hlcode-line-fold hidden \" data-fold-id=\"hlcode-fold-21\"><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-meta\">@Service</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserDetailsServiceImpl</span>(\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-comment\">// The komapper spring-boot starter is aware of spring managed</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-comment\">// datasources configured through application.properties</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-comment\">//</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-comment\">// so we will not need to define this bean separately</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> db: JdbcDatabase\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">): UserDetailsService {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">loadUserByUsername</span><span class=\"hljs-params\">(username: <span class=\"hljs-type\">String</span>)</span></span>: UserDetails {\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        <span class=\"hljs-comment\">// Fetch a user from database using the username coming from the form</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        <span class=\"hljs-keyword\">val</span> userQuery = QueryDsl.from(Meta.user)\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">            .<span class=\"hljs-keyword\">where</span> { user.name eq username }\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">            .first() <span class=\"hljs-comment\">// Throws if user is not found</span>\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        <span class=\"hljs-keyword\">return</span> UserDetailsImpl(db.runQuery(userQuery))\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    }\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> user = Meta.user\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">}\n</td></tr></table></code></pre>\n\n<p>The Meta.user is an extension method generated by komapper&#39;s ksp processor that returns the meta-model instance for the User entity defined above.\nMode details about komapper&#39;s meta-model approach is available <a href=\"https://v0-24.komapper.org/docs/overview/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">here</a>.</p>\n<p>We will need a wrapper over our User class that complies with the UserDetails interface that spring-security expects:</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserDetailsImpl</span>(<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> user: User): UserDetails &#123;\n\n    <span class=\"hljs-comment\">// We prefix the password stored in database with &#123;bcrypt&#125; to indicate</span>\n    <span class=\"hljs-comment\">// to spring-security that this password is bcrypt encrypted.</span>\n    <span class=\"hljs-comment\">//</span>\n    <span class=\"hljs-comment\">// This prefix will be used to identify the password encoder to be used</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getPassword</span><span class=\"hljs-params\">()</span></span> = <span class=\"hljs-string\">&quot;&#123;bcrypt&#125;<span class=\"hljs-subst\">$&#123;user.password&#125;</span>&quot;</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getUsername</span><span class=\"hljs-params\">()</span></span> = user.name\n\n    <span class=\"hljs-comment\">// In a more full-featured integration, we can use below</span>\n    <span class=\"hljs-comment\">// overrides to ensure that current user is not locked/expired/disabled etc.</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">isAccountNonExpired</span><span class=\"hljs-params\">()</span></span> = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">isAccountNonLocked</span><span class=\"hljs-params\">()</span></span> = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">isCredentialsNonExpired</span><span class=\"hljs-params\">()</span></span> = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">isEnabled</span><span class=\"hljs-params\">()</span></span> = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getAuthorities</span><span class=\"hljs-params\">()</span></span> = <span class=\"hljs-literal\">null</span>\n&#125;</code></pre>\n\n<p>Now, if we try to access localhost:8080 we will be prompted for username, password and our &#96;UserDetailsServiceImpl will be automatically used to find the corresponding user before password is validated.</p>\n<p>However, we don&#39;t have a built-in way to manage&#x2F;insert users. To test out things we can insert a user directly in the db. One simple way to generate an encrypted password is to use the <a href=\"https://www.npmjs.com/package/bcrypt-cli\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">bcrypt-cli</a> utility available through npm.</p>\n<pre><code class=\"hljs plaintext\"> npx bcrypt-cli &quot;sillypassword&quot; 10\nNeed to install the following packages:\n  bcrypt-cli\nOk to proceed? (y) y\n$2a$10$drlJ6SdzEBso.CLHkO9W0e/lMtySOyArGmixOiSvOESMYBHvEEBoO</code></pre>\n\n<p>We can insert this as user password into the h2 db:</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> users (name, email, password)\n<span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;test&#x27;</span>, <span class=\"hljs-string\">&#x27;test@example.com&#x27;</span>, <span class=\"hljs-string\">&#x27;$2a$10$drlJ6SdzEBso.CLHkO9W0e/lMtySOyArGmixOiSvOESMYBHvEEBoO&#x27;</span>)</code></pre>\n\n<p>Now, we should be able to login through test&#x2F;sillypassword as credentials.</p>\n",
            "tags": [
                "kotlin",
                "spring",
                "spring-security",
                "komapper"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/01/29/hiding-jsx-closing-tag-noise-in-vim/",
            "url": "https://lorefnon.me/2022/01/29/hiding-jsx-closing-tag-noise-in-vim/",
            "title": "Hiding JSX closing tag noise in vim through conceal",
            "date_published": "2022-01-29T00:00:00.000Z",
            "content_html": "<p>Thanks to popularity of React and other frameworks that have partly embraced its idioms, the verbose JSX syntax extension to javascript remains quite popular in 2022, despite the declining popularity of XML in the industry at large.</p>\n<p>While alternatives exist, in most existing projects one can expect to find JSX in use, and alternatives usually don&#39;t have as great support from typescript, which has first class support for JSX.</p>\n<p>Here is a simple tip that makes code using JSX easier to quickly scan through in vim by getting rid of the closing tag noise at editor level. While the tags still exist in the source code we simply collapse them in the editor. Any project level or source level changes are thus not needed.</p>\n<p>The end result looks like this:</p>\n<p><img src=\"/images/collapsed-end-tags.png\" alt=\"Collapsed end tags\" loading=\"lazy\"></p>\n<p>This is achieved by utilizing the <a href=\"https://vimhelp.org/syntax.txt.html#conceal\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">conceal feature</a> of vim. While the configuration here has only been tested in neovim, it should work on vanilla vim as well.</p>\n<p>To achieve the above, we can add the following to <code>~/.config/nvim/after/syntax/typescriptreact.vim</code>:</p>\n<pre><code class=\"hljs plaintext\">if exists(&#x27;g:no_vim_conceal&#x27;) || !has(&#x27;conceal&#x27;) || &amp;enc != &#x27;utf-8&#x27;\n  finish\nendif\n\nsyntax match tsxCloseTag &quot;&lt;/.*&gt;&quot; conceal cchar=\nsetlocal conceallevel=1</code></pre>\n\n<p>Now any text matching <code>&lt;/.*&gt;</code> will be concealed and a diamond symbol be shown instead. However if we put the cursor on the specific line, we&#39;ll see the actual source.</p>\n<p>If you need more info about the <code>after</code> directory in vim (as used above) this <a href=\"https://vimhelp.org/options.txt.html#after%2ddirectory\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">vimhelp topic</a> and this <a href=\"https://vi.stackexchange.com/questions/4975/how-can-i-add-additional-syntax-highlighting-rules-in-my-local-vimrc\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">stackexchange thread</a> are good resources.</p>\n<p>If you are wondering how to identify the tag name for other syntax forms eg. the <code>function</code> keyword, this <a href=\"https://github.com/gerw/vim-HiLinkTrace\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">vim plugin</a> can provide you the complete trace of syntax highlight.</p>\n<p>In my setup, <code>:HLT</code> gives me the following trace for a closing tag:</p>\n<pre><code class=\"hljs plaintext\">typescriptBlock-&gt;typescriptParenExp-&gt;tsxRegion-&gt;tsxRegion-&gt;tsxRegion-&gt;tsxRegion-&gt;tsxRegion-&gt;tsxRegion-&gt;tsxCloseTag  HltTrace: tsxCloseTag-&gt;htmlTag-&gt;GruvboxBlue   fg&lt;109&gt; bg&lt;&gt;</code></pre>\n",
            "tags": [
                "vim"
            ]
        },
        {
            "id": "https://lorefnon.me/2021/12/05/extending-exposed-with-custom-operators/",
            "url": "https://lorefnon.me/2021/12/05/extending-exposed-with-custom-operators/",
            "title": "Extending Exposed with new function expressions",
            "date_published": "2021-12-05T00:00:00.000Z",
            "content_html": "<p><a href=\"https://github.com/JetBrains/Exposed\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Exposed</a> is a nice ORM for Kotlin by <a href=\"https://github.com/Tapac\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Andrey Tarashevskiy</a> from <a href=\"https://www.jetbrains.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Jetbrains</a>. Though, not an offically supported product by Jetbrains it has a good following in the Kotlin community. </p>\n<p>I recently got involved in a project using Exposed and discovered that the set of database level functions that are mapped by Exposed is quite small. However, the library makes it easy to add support for the missing functions, which is what this post outlines. </p>\n<p>Let&#39;s say we want to support product of two columns. We can support this by extending the <code>ExpressionWithColumnType</code> class.</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Product</span>&lt;<span class=\"hljs-type\">T</span>&gt;(\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> expr1: ExpressionWithColumnType&lt;T&gt;,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> expr2: ExpressionWithColumnType&lt;T&gt;\n): ExpressionWithColumnType&lt;T&gt;() &#123;\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">val</span> columnType: IColumnType\n        <span class=\"hljs-keyword\">get</span>() = expr1.columnType\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">toQueryBuilder</span><span class=\"hljs-params\">(queryBuilder: <span class=\"hljs-type\">QueryBuilder</span>)</span></span> &#123;\n        queryBuilder.append(<span class=\"hljs-string\">&quot;(&quot;</span>, expr1, <span class=\"hljs-string\">&quot;*&quot;</span>, expr2, <span class=\"hljs-string\">&quot;)&quot;</span>)\n    &#125;\n&#125;</code></pre>\n\n<p>This accepts two columns (Column class extends ExpressionWithColumnType too) of same type, and constructs the expression for multiplying these column values. </p>\n<p>While this class can be used directly, it is often convenient to also write an extension method that enables us to chain the operations similar to other exposed functions. </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-type\">&lt;T&gt;</span> ExpressionWithColumnType<span class=\"hljs-type\">&lt;T&gt;</span>.<span class=\"hljs-title\">product</span><span class=\"hljs-params\">(expr: <span class=\"hljs-type\">ExpressionWithColumnType</span>&lt;<span class=\"hljs-type\">T</span>&gt;)</span></span> =\n    Product(<span class=\"hljs-keyword\">this</span>, expr)</code></pre>\n\n<p>So now, we can easily use this in our code as: </p>\n<pre><code class=\"hljs kotlin\">DesginationTable\n    .slice(\n        DesignationTable.name,\n        DesginationTable.employeeCount.product(DesginationTable.salary)\n    )\n    .groupBy(DesignationTable.name)\n    .toList()</code></pre>\n\n<p>It is usually also convenient to use an alias to retrieve aggregated values: </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DesignationSalaryDTO</span>(\n    <span class=\"hljs-keyword\">val</span> name: String,\n    <span class=\"hljs-keyword\">val</span> totalSalary: <span class=\"hljs-built_in\">Double</span>\n)\n\n<span class=\"hljs-keyword\">val</span> totalSalary = DesginationTable.employeeCount.product(DesginationTable.salary).alias(<span class=\"hljs-string\">&quot;total_salary&quot;</span>)\n\n<span class=\"hljs-keyword\">val</span> salaryRow DesginationTable\n    .slice(\n        DesignationTable.name, \n        <span class=\"hljs-comment\">// We can use the alias in our slice</span>\n        totalSalary\n    )\n    .groupBy(DesignationTable.name)\n    .map &#123; resultRow -&gt;\n        <span class=\"hljs-comment\">// Map results to a DTO</span>\n        DesignationSalaryDTO(\n            name = DesignationTable.name,\n            <span class=\"hljs-comment\">// We can use the same alias when retrieving the column value</span>\n            totalSalary = resultRow[totalSalary]\n        )\n    &#125;</code></pre>\n\n<p>This illustrates how we can nicely add our extension functions for operations that the library does not support, and use them in pretty much the same way as built in expression composition functions. </p>\n",
            "tags": [
                "Database",
                "Exposed"
            ]
        },
        {
            "id": "https://lorefnon.me/2021/12/15/mapping-between-domain-and-dtos-for-grpc/",
            "url": "https://lorefnon.me/2021/12/15/mapping-between-domain-and-dtos-for-grpc/",
            "title": "Mapping between Domain and DTO classes for gRPC APIs",
            "date_published": "2021-12-05T00:00:00.000Z",
            "content_html": "<p>In a <a href=\"/2021/09/04/bootstrapping-a-grpc-server-with-spring-boot-and-kotlin\">previous post</a> we briefly explored how to build a gRPC api backend with Kotlin. </p>\n<p>In particular, we saw that from the protobuf spec which defines our API, the <a href=\"https://grpc.io/docs/protoc-installation/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">protoc compiler</a> (along with language specific plugins) is able to generate classes for the language(s) in which our server (or client) is implemented. </p>\n<p>To exemplify for our case (a kotlin&#x2F;JVM backend), given a proto spec like this: </p>\n<pre><code class=\"hljs protobuf\"><span class=\"hljs-keyword\">message </span><span class=\"hljs-title class_\">User</span> &#123;\n  <span class=\"hljs-type\">int64</span> id = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-type\">string</span> name = <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-type\">string</span> email = <span class=\"hljs-number\">3</span>;\n&#125;</code></pre>\n\n<p>The code generator generates an immutable User java class, and an associated builder, which we can invoke like this: </p>\n<pre><code class=\"hljs kotlin\">User\n    .newBuilder()\n    .setId(<span class=\"hljs-number\">1</span>)\n    .setName(<span class=\"hljs-string\">&quot;Lorefnon&quot;</span>)\n    .build()</code></pre>\n\n<p>We also get a set of kotlin extensions, which enable us to do the same thing through a more idiomatic kotlin builder: </p>\n<pre><code class=\"hljs kotlin\">user &#123;\n    id = <span class=\"hljs-number\">1</span>\n    name = <span class=\"hljs-string\">&quot;Lorefnon&quot;</span>\n&#125;</code></pre>\n\n<p>Note that in this post we mostly consider the official proto plugins for Java &amp; Kotlin (which are complementary) by Google. Generated code may substantially differ for other alternative implementations like <a href=\"https://github.com/marcoferrer/kroto-plus\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">kroto-plus</a> and <a href=\"https://github.com/streem/pbandk\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">pbandk</a>.</p>\n<p>These classes are primarily intended for deserializing from and serializing to the protobuf format. The conventional term in the JVM ecosystem for such classes, which are primarily intended to transport the data across API boundaries is DTO (Data Transfer Object).</p>\n<p>Now the question arises, what do we use in our business logic ?</p>\n<h2 id=\"Option-1-Using-the-generated-classes-in-core-business-logic-as-well\"><a href=\"#Option-1-Using-the-generated-classes-in-core-business-logic-as-well\" class=\"headerlink\" title=\"Option 1: Using the generated classes in core business logic as well.\"></a>Option 1: Using the generated classes in core business logic as well.</h2><p>There is nothing really preventing us from using the generated class in our business logic as well. </p>\n<p>However, we should be aware of some restrictions: </p>\n<ol>\n<li><p>Generated DTOs are final: </p>\n<p> This means that we can&#39;t inherit from these classes, can&#39;t extend them with internal fields (not part of the API) and can&#39;t add behaviors (methods) to them. </p>\n</li>\n<li><p>They are immutable:</p>\n<p> So whenever we need to get an updated entity, we will need to clone the entity with modifications.</p>\n</li>\n</ol>\n<p>Thus, using the DTOs as Domain classes as well works well primarily when the business logic is entirely implemented as functional services. </p>\n<p>However, if you need mutability or are not so happy with <a href=\"https://martinfowler.com/bliki/AnemicDomainModel.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">anaemic domain models</a>, we have a few options.</p>\n<h2 id=\"Option-2-Pass-around-the-builders\"><a href=\"#Option-2-Pass-around-the-builders\" class=\"headerlink\" title=\"Option 2: Pass around the builders\"></a>Option 2: Pass around the builders</h2><p>One thing that may not be obvious to developers used to conventional java builders, is that the builders generated from protobuf have both getters and setters. </p>\n<p>So when we need mutability, we can just use the builders and call build only once the object needs to be serialized. </p>\n<p>I recommend doing this only internally within a service class, and not have the builders be passed around across services. </p>\n<p>One reason for this is that in a method that receives a builder instance, we don&#39;t have any guarantee from the compiler that all non-optional values have been populated. </p>\n<h2 id=\"Option-3-Compose-over-the-builders\"><a href=\"#Option-3-Compose-over-the-builders\" class=\"headerlink\" title=\"Option 3: Compose over the builders\"></a>Option 3: Compose over the builders</h2><p>A class that composes over the builder can: </p>\n<ol>\n<li>Ensure that any consumer never receives a partially populated builder</li>\n<li>Add behavior to a builder class - I have found this to be particularly useful for things like computed values (like age derived from created_at) which logically belong in the entity class.</li>\n</ol>\n<p>While this would have been cumbersome &amp; boilerplate heavy in java, Kotlin&#39;s support for interface delegation comes in really handy here. </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserBuilder</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">constructor</span>(\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> internalBuilder: User.Builder\n): UserOrBuilder <span class=\"hljs-keyword\">by</span> internalBuilder &#123;\n\n    <span class=\"hljs-comment\">// To be used when constructing new objects</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">constructor</span>(\n        name: String,\n        email: String\n        <span class=\"hljs-comment\">// Other fields whose presence we want to enforce</span>\n    ): <span class=\"hljs-keyword\">this</span>(\n        User\n            .newBuilder()\n            .setName(name)\n            .setEmail(email)\n    )\n\n    <span class=\"hljs-comment\">// To be used when deserializing previously serialized entity </span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">constructor</span>(\n        inputStream: InputStream\n    ): <span class=\"hljs-keyword\">this</span>(\n        User.newBuilder().mergeFrom(inputStream)\n\n        <span class=\"hljs-comment\">// If we had successfully serialized, then we know that all mandatory fields will be present</span>\n        <span class=\"hljs-comment\">//</span>\n        <span class=\"hljs-comment\">// But we can add validations if we are consuming multiple generations of serialized entities</span>\n    )\n\n    <span class=\"hljs-comment\">// If needed, define similar constructors to consume ByteArray/ByteString</span>\n\n    <span class=\"hljs-comment\">// Define setters for fields for which you want to explicitly allow mutation</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(mail: <span class=\"hljs-type\">String</span>)</span></span> &#123;\n        internalBuilder.email = mail\n    &#125;\n&#125;</code></pre>\n\n<p>The UserOrBuilder is a generated interface which contains all the getters. By delegating to this interface through the builder, we can directly invoke all the setters directly on an instance of our <code>UserBuilder</code> class, and they&#39;ll be proxied to the underlying builder.</p>\n<p>By ensuring that our constructor accepts all mandatory parameters, our consumers are guaranteed to never receive partially populated builders. </p>\n<p>Also, we are explicit about which fields we want to allow mutation for. </p>\n<p>The only caveat with this approach is that it is quite a bit of boilerplate because a large set of fields have to enumerated over in the constructor. </p>\n<h2 id=\"Option-4-Use-a-mapping-library-like-MapStruct\"><a href=\"#Option-4-Use-a-mapping-library-like-MapStruct\" class=\"headerlink\" title=\"Option 4: Use a mapping library like MapStruct\"></a>Option 4: Use a mapping library like MapStruct</h2><p>MapStruct is a really nice model mapping library for java that has good support for Kotlin and protobuf style builders. </p>\n<p>One great feature of the library, as compared to many other similar model mapping libraries is that there is no reflection involved during mapping - which makes this library very performant in practice. </p>\n<p>Application developers need to define mapper interfaces, and at compile time MapStruct will generate mapper classes which convert between one type to another. </p>\n<p>With this library, we can define our domain classes as Kotlin (data) classes and have them mapped to&#x2F;from the API classes at the API service layer. </p>\n<p>Following are the primary dependencies we need: </p>\n<pre><code class=\"hljs kotlin\">implementation(<span class=\"hljs-string\">&quot;org.mapstruct:mapstruct:1.4.2.Final&quot;</span>)\nkapt(<span class=\"hljs-string\">&quot;org.mapstruct:mapstruct-processor:1.4.2.Final&quot;</span>)\nkapt(<span class=\"hljs-string\">&quot;no.entur.mapstruct.spi:protobuf-spi-impl:1.18&quot;</span>)</code></pre>\n\n<p>In a spring project, we&#39;d also want MapStruct to automatically annotate generated classes with <code>@Component</code> so that we can directly inject them in our services: </p>\n<pre><code class=\"hljs kotlin\">kapt &#123;\n    arguments &#123;\n        arg(<span class=\"hljs-string\">&quot;mapstruct.defaultComponentModel&quot;</span>, <span class=\"hljs-string\">&quot;spring&quot;</span>)\n    &#125;\n&#125;</code></pre>\n\n<p>Now, we can define a mapper abstract class or interface, which MapStruct will use to generate our Mappers: </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-meta\">@Mapper(</span>\n<span class=\"hljs-meta\">    // We can not assign null to setters in protobuf builders</span>\n<span class=\"hljs-meta\">    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE,</span>\n<span class=\"hljs-meta\">    nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS,</span>\n<span class=\"hljs-meta\"></span>\n<span class=\"hljs-meta\">    // For collection members (repeated fields in protobuf), we should use </span>\n<span class=\"hljs-meta\">    // the add* methods rather than set* methods</span>\n<span class=\"hljs-meta\">    collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED</span>\n<span class=\"hljs-meta\">)</span>\n<span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DTOMapper</span> &#123;\n    <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">mapUserFromPB</span><span class=\"hljs-params\">(source: <span class=\"hljs-type\">User</span>)</span></span>: UserEntity\n    <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">mapUserToPB</span><span class=\"hljs-params\">(source: <span class=\"hljs-type\">UserEntity</span>)</span></span>: User\n&#125;</code></pre>\n\n<p>Here <code>User</code> entity is the class generated from protobuf, and <code>UserEntity</code> is our internal domain class.</p>\n<p>For this particular example, this is all we need if our fields have the same name in both classes, and the generated classes and the domain classes use the same types. </p>\n<p>In real world applications, both of these will sometimes not be true. However, to handle these special cases we can configure MapStruct with custom mappings and specify shared type mappers.</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DTOMapper</span> &#123;\n\n    <span class=\"hljs-comment\">// Custom mapping for field</span>\n    <span class=\"hljs-meta\">@Mappings(</span>\n<span class=\"hljs-meta\">        value = [</span>\n<span class=\"hljs-meta\">            Mapping(source = <span class=\"hljs-string\">&quot;mailAddress&quot;</span>, target = <span class=\"hljs-string\">&quot;email&quot;</span>)</span>\n<span class=\"hljs-meta\">        ]</span>\n<span class=\"hljs-meta\">    )</span>\n    <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">mapUserFromPB</span><span class=\"hljs-params\">(source: <span class=\"hljs-type\">User</span>)</span></span>: UserEntity\n\n    <span class=\"hljs-comment\">// Convert between types used in Domain classes and DTOs</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">map</span><span class=\"hljs-params\">(value: <span class=\"hljs-type\">Date</span>)</span></span> =\n        LocalDate.of(value.year, value.month, value.day)\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">map</span><span class=\"hljs-params\">(value: <span class=\"hljs-type\">LocalDate</span>)</span></span>: Date =\n        Date.newBuilder()\n            .setDay(value.dayOfMonth)\n            .setMonth(value.monthValue)\n            .setYear(value.year)\n            .build()\n&#125;</code></pre>\n\n<p>MapStruct <a href=\"https://mapstruct.org/documentation/installation/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">docs</a> cover all possible options in much more detail.</p>\n<p>In our RPC service implementations, we can inject our mappers and use them to transform inputs before delegating to internal classes, and after receiving the results from the internal classes. </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-meta\">@GrpcService</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserRPCService</span>(\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> userRepo: UserRepository,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> mapper: DTOMapper\n) : UserServiceGrpcKt.UserServiceCoroutineImplBase() &#123;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(request: <span class=\"hljs-type\">UserIdRequest</span>)</span></span>: User &#123;\n        <span class=\"hljs-keyword\">return</span> mapper.mapUserToPB(userRepo.getUser(request.id))\n    &#125;\n\n&#125;</code></pre>\n\n<p>This is the option with minimum boilerplate, but has the trade-off of needing additional heap allocations. However, it is usually an acceptable tradeoff when the types used in the DTOs often differ from the the types used in the domain classes or when we need multiple representations of the same domain class(es) in the API layer (with different set of fields).</p>\n",
            "tags": [
                "Kotlin",
                "Spring",
                "Spring-Boot",
                "gRPC"
            ]
        }
    ]
}