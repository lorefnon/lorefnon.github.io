{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"babel\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2022/12/13/auto-transforming-modules-to-mjs-node/",
            "url": "https://lorefnon.me/2022/12/13/auto-transforming-modules-to-mjs-node/",
            "title": "Auto-transforming modules to mjs using babel",
            "date_published": "2022-12-13T00:00:00.000Z",
            "content_html": "<p>The unfortunate reality of being a js library author in present day world is that we need to deal with multiple module systems and bundlers, which make life hard. </p>\n<p>While commonjs usage is declining, many users are yet to move to esm fully.</p>\n<p>Solutions like tsup provide a nice DX for deploying libraries by bundling separately to an artifact of each configured module type. </p>\n<p>However, for nodejs libraries I often prefer to not bundle my libraries, and thankfully babel ecosystem makes it easy to handle these scenarios.</p>\n<p>This post outlines a simple babel setup where: </p>\n<ol>\n<li><p>We author code without needing explicit extensions in import: </p>\n <pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// bar.ts</span>\n\n<span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./foo&quot;</span></code></pre>\n</li>\n<li><p>As part of build, we generate <code>.mjs</code> modules where the relative imports are also transformed to use <code>.mjs</code>:</p>\n <pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// bar.mjs</span>\n\n<span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./foo.mjs&quot;</span></code></pre></li>\n</ol>\n<p>Benefit of this setup is that the generated .mjs modules can co-exist alongside .cjs modules.</p>\n<p>Consumers of the module can either explicitly import with mjs extension (eg. <code>import &#123; foo &#125; from &quot;foo-lib/foo.mjs&quot;</code>) or configure their bundler&#x2F;runtime to default to mjs if they prefer mjs.</p>\n<p>Note that this setup does not fully emulate node-specific module resolution. For example: <code>import &#123; foo &#125; from &quot;./foo&quot;</code> will not be auto-resolved to <code>import &#123; foo &#125; from &quot;./foo/index.js&quot;</code> if foo is directory.</p>\n<p>Babel config: </p>\n<pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;\n    <span class=\"hljs-attr\">presets</span>: [\n        <span class=\"hljs-string\">&#x27;@babel/preset-typescript&#x27;</span>,\n        [<span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>, &#123;\n            <span class=\"hljs-attr\">targets</span>: &#123;\n                <span class=\"hljs-attr\">node</span>: <span class=\"hljs-number\">16</span>\n            &#125;,\n            <span class=\"hljs-attr\">modules</span>: <span class=\"hljs-literal\">false</span>\n        &#125;]\n    ],\n    <span class=\"hljs-attr\">plugins</span>: [\n        [<span class=\"hljs-string\">&#x27;babel-plugin-replace-import-extension&#x27;</span>, &#123;\n            <span class=\"hljs-attr\">extMapping</span>: &#123;\n                <span class=\"hljs-string\">&#x27;&#x27;</span>: <span class=\"hljs-string\">&#x27;.mjs&#x27;</span>\n            &#125;\n        &#125;]\n    ]\n&#125;</code></pre>\n\n<pre><code class=\"hljs sh\">babel src \\\n    --config-file ./babel.esm.config.js \\\n    --out-dir dist \\\n    --out-file-extension <span class=\"hljs-string\">&quot;.mjs&quot;</span> \\\n    --extensions <span class=\"hljs-string\">&quot;.ts&quot;</span> \\\n    --ignore <span class=\"hljs-string\">&quot;**/*.d.ts&quot;</span></code></pre>\n\n",
            "tags": [
                "Javascript",
                "Babel"
            ]
        }
    ]
}