{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"gulp\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2014/03/10/decoupling-frontend-with-gulp-and-node-http-proxy.html",
            "url": "https://lorefnon.me/2014/03/10/decoupling-frontend-with-gulp-and-node-http-proxy.html",
            "title": "Decoupling your frontend development with gulp and http-proxy",
            "date_published": "2014-03-09T18:30:00.000Z",
            "content_html": "<p>In past developers have often relied on backend-specific toolchains for\nweb application frontends. Some examples would be <a href=\"http://edgeguides.rubyonrails.org/asset_pipeline.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Rails asset pipeline</a> or\nthe legacy ant based toolchain for YUI. However recently node.js based tooling support\nfor frontend technologies has significantly evolved and it is quite viable\nto use a node.js based toolchain for managing your frontend projects, even if\nthe backend is not node.js, thus keeping the workflow decoupled from the backend.</p>\n<p>This has multiple advantages, primary among them being that javascript\ndevelopers can configure their tools using a language they already are\nfamiliar with without relying on server-side developers.</p>\n<p>The workflow I outline in this post utilizes <a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">gulp</a> and node module <a href=\"https://www.npmjs.org/package/http-proxy\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">http-proxy</a>.</p>\n<p>Gulp is a build system. I prefer it over alternative task runners like grunt\nand mimosa because, as the gulp&#39;s website states quite succinctly :</p>\n<blockquote>\n<p>gulp&#39;s use of streams and code-over-configuration makes for a simpler and more intuitive build.</p>\n</blockquote>\n<p>A claim that I have found to be true in practice.</p>\n<p>The http-proxy library helps us connect with our backend seemlessly and at the same\ntime keep the codebase in a separate project. By configuring a proxy server\nwe can load frontend assets from our local system while route the rest of the\nrequests to a potentially remote backend. This is particularly helpful when\nwe have multiple loosely coupled mini-applications backed by a single monolithic\nserver-side codebase.</p>\n<p>An alternative to this would be to configure the backend to support <a href=\"http://www.html5rocks.com/en/tutorials/cors/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">cross origin\nrequests</a>, but this is really unnecessary if eventually the application will be\nserved from the same domain.</p>\n<p>Let us say we have a javascript heavy dashboard which we would like to develop\nin a separate project. Here is the directory structure I&#39;ll use. Please note that following this\ndirectory structure is not mandatory and is mainly illustrative.</p>\n<pre><code class=\"hljs bash\">project\n  |_ gulpfile.js    <span class=\"hljs-comment\"># task runner configuration</span>\n  |_ dashboard      <span class=\"hljs-comment\"># generated files go here</span>\n  |  |_ css\n  |  |_ js\n  |_ node_modules   <span class=\"hljs-comment\"># node.js dependencies are installed here</span>\n  |_ package.json   <span class=\"hljs-comment\"># configuration for node.js packages</span>\n  |_ server.js      <span class=\"hljs-comment\"># proxy server</span>\n  |_ src            <span class=\"hljs-comment\"># source files</span>\n     |_ css\n     |_ js</code></pre>\n\n<p>When deploying the application we can simply drop the dashboard folder to the\nweb-root of our application eg. the public folder of a Rails application.</p>\n<p>Next we illustrate usage of http-proxy module to create a simple proxy server.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// server.js</span>\n\n<span class=\"hljs-keyword\">var</span> httpProxy = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http-proxy&#x27;</span>),\n    connect = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;connect&#x27;</span>),\n    livereload = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;connect-livereload&#x27;</span>)\n\n<span class=\"hljs-keyword\">var</span> proxy = httpProxy.createProxyServer()\n\n<span class=\"hljs-keyword\">var</span> app = connect()\n    .use(<span class=\"hljs-string\">&#x27;/dashboard&#x27;</span>, connect.static(__dirname+<span class=\"hljs-string\">&#x27;/dashboard&#x27;</span>))\n    .use(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req, res</span>)</span>&#123;\n        <span class=\"hljs-keyword\">if</span> (req.url.indexOf(<span class=\"hljs-string\">&#x27;dashboard&#x27;</span>) == -<span class=\"hljs-number\">1</span>) &#123;\n            proxy.web(req, res, &#123;\n                target: <span class=\"hljs-string\">&#x27;http://localhost:3000&#x27;</span>\n            &#125;)\n        &#125;\n    &#125;)\n    .listen(<span class=\"hljs-number\">4000</span>)</code></pre>\n\n<p>Before running the server, install the node.js dependencies:</p>\n<pre><code class=\"hljs bash\">npm install --save connect http-proxy connect-livereload</code></pre>\n\n<p>What the above script does is simply serve the urls that\nhave dashboard in the url from dashboard folder while\ndirecting the rest of the requests to another server, which\nin case is simply <code>http://localhost:3000</code></p>\n<p>For complex routing we can use some of the <a href=\"https://nodejsmodules.org/tags/router\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">routing libraries</a>\nfor node.js but for our example the simple script above works\npretty well.</p>\n<p>Our gulp tasks go in gulpfile.js. Configuring gulp tasks is fairly\nsimple. While the <a href=\"https://github.com/gulpjs/gulp/blob/master/docs/README.md\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">official documentation</a>\nis a thorough reference, we illustrate the workflow through some examples.\nFor example creating a task to clean our target js and css\nfolders is as simple as:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gulp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;gulp&#x27;</span>),\n    clean = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;gulp-clean&#x27;</span>)\n\ngulp.task(<span class=\"hljs-string\">&#x27;clean&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    gulp.src([<span class=\"hljs-string\">&#x27;./dashboard/js/*&#x27;</span>, <span class=\"hljs-string\">&#x27;./dashboard/css/*&#x27;</span>])\n        .pipe(clean())\n&#125;)</code></pre>\n\n<p>The stream based based approach really shines when we use pre-processors for\nour js or css files. For example to use stylus for css we can add:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> stylus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;gulp-stylus&#x27;</span>)\n\ngulp.task(<span class=\"hljs-string\">&#x27;css&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    gulp.src(<span class=\"hljs-string\">&#x27;./src/css/*.styl&#x27;</span>)\n        .pipe(stylus())\n        .pipe(gulp.dest(<span class=\"hljs-string\">&#x27;./dashboard/css&#x27;</span>))\n&#125;)</code></pre>\n\n<p>To manage dependencies with browserify we can have:</p>\n<pre><code class=\"hljs javascript\">gulp.task(<span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    gulp.src(<span class=\"hljs-string\">&#x27;./src/js/index.js&#x27;</span>)\n        .pipe(browserify())\n        .pipe(gulp.dest(<span class=\"hljs-string\">&#x27;./dashboard/js&#x27;</span>))\n&#125;)\n</code></pre>\n\n<p>As I hope is clear, the stream based approach makes configuration fairly\nsimple, intuitive and consistent throughout.</p>\n<p>Of course associated packages above like <code>gulp-stylus</code>, <code>gulp-browserify</code>, <code>gulp-clean</code>\nhave to be installed through npm before we can use them.</p>\n<p>While we can run <code>gulp js</code>, <code>gulp css</code>, <code>gulp clean</code> etc. from the command line\nwe would probably want to have a default task that we run most of the time:</p>\n<pre><code class=\"hljs javascript\">gulp.task(<span class=\"hljs-string\">&#x27;default&#x27;</span>, [<span class=\"hljs-string\">&#x27;clean&#x27;</span>, <span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-string\">&#x27;css&#x27;</span>])</code></pre>\n\n<p>Now running <code>gulp</code> will cleanup the dashboard/js and dashboard/css folders and\nrun our js and css tasks.</p>\n<p>To streamline our workflow we configure a watcher which can monitor our files, and\nrun the associated tasks automatically. Writing a simple watcher is as simple as:</p>\n<pre><code class=\"hljs javascript\">gulp.task(<span class=\"hljs-string\">&#x27;watch&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    gulp.watch(<span class=\"hljs-string\">&#x27;./src/js/**/*&#x27;</span>, [<span class=\"hljs-string\">&#x27;default&#x27;</span>])\n&#125;)</code></pre>\n\n<p>And why stop here, let us automate browser refreshes too. We can use <a href=\"http://livereload.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">livereload</a> to\nautomatically reload our browser whenever the files change.</p>\n<p>We can add a watcher that notifies the livereload server with changes:</p>\n<pre><code class=\"hljs javascript\">gulp.task(<span class=\"hljs-string\">&#x27;watch&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">var</span> server = livereload()\n    gulp.watch(<span class=\"hljs-string\">&#x27;./src/js/**/*&#x27;</span>, [<span class=\"hljs-string\">&#x27;default&#x27;</span>])\n    gulp.watch(<span class=\"hljs-string\">&#x27;./dashboard/**/*&#x27;</span>)\n        .on(<span class=\"hljs-string\">&#x27;change&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">file</span>)</span>&#123;\n            server.changed(file.path)\n        &#125;)\n&#125;)</code></pre>\n\n<p>Please note that we could not have hooked up the callback to the watcher we\nalready had because then it would not guarantee that the pre-processors have\nactually completed before our browser refreshes. Please never use timers for\nsituations like this.</p>\n<p>If you have been using livereload for a while then you probably have the browser\nextension for livereload. But in case you haven&#39;t you can use a middleware for\nexpress in the server.js file. This is especially convenient for testing on\nseveral browsers.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> app = connect()\n    .use(connect.logger(<span class=\"hljs-string\">&#x27;dev&#x27;</span>))\n    .use(livereload(&#123;\n        port: <span class=\"hljs-number\">35729</span>\n    &#125;))\n    .use(<span class=\"hljs-string\">&#x27;/dashboard&#x27;</span>, connect.static(__dirname+<span class=\"hljs-string\">&#x27;/dashboard&#x27;</span>))\n    .use(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req, res</span>)</span>&#123;\n        <span class=\"hljs-keyword\">if</span> (req.url.indexOf(<span class=\"hljs-string\">&#x27;dashboard&#x27;</span>) == -<span class=\"hljs-number\">1</span>) &#123;\n            proxy.web(req, res, &#123;\n                target: <span class=\"hljs-string\">&#x27;http://localhost:3000&#x27;</span>\n            &#125;)\n        &#125;\n    &#125;)\n    .listen(<span class=\"hljs-number\">4000</span>)</code></pre>\n\n<p>35729 is the default port on which livereload server runs. Note that this\nrelieves us from having to add the livereload script in our page manually\nbecause the middleware takes care of it for us.</p>\n<p>If you use the above configuration, you will soon notice something strange.\nWhen we edit a css file our entire page refreshes. If you have used livereload\nbefore or have seen the demos you know that this should not happen. It should\njust transparently reload the css files.</p>\n<p>It happens because of the way our gulp tasks are configured. Whenever a file\nin src directory changes we run both our js and css tasks which cause both\njs and css files to be regerated and thus prompt livereload to refresh the page.</p>\n<p>To remedy this we have to modify the watch handler:</p>\n<pre><code class=\"hljs javascript\">gulp.task(<span class=\"hljs-string\">&#x27;watch&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">var</span> server = livereload()\n    gulp.watch(<span class=\"hljs-string\">&#x27;./src/js/**/*.js&#x27;</span>, [<span class=\"hljs-string\">&#x27;js&#x27;</span>])\n    gulp.watch(<span class=\"hljs-string\">&#x27;./src/css/**/*.styl&#x27;</span>, [<span class=\"hljs-string\">&#x27;css&#x27;</span>])\n    gulp.watch(<span class=\"hljs-string\">&#x27;./dashboard/**/*&#x27;</span>)\n        .on(<span class=\"hljs-string\">&#x27;change&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">file</span>)</span>&#123;\n            server.changed(file.path)\n        &#125;)\n&#125;)</code></pre>\n\n<p>If you try now, you will notice that css changes no longer refresh the full\npage as expected.</p>\n<p>While the above was not an indepth introduction to any of the technologies involved,\nI hope that it gave a basic idea about how node.js based tools can be used\nfor a streamlined frontend development workflow. As always any comment or criticism is\nwelcome.</p>\n",
            "tags": [
                "Javascript",
                "Gulp"
            ]
        }
    ]
}