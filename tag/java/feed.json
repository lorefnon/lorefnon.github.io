{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"java\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2021/08/03/Adapting-Jooq-To-Rails-DB-Naming-Conventions/",
            "url": "https://lorefnon.me/2021/08/03/Adapting-Jooq-To-Rails-DB-Naming-Conventions/",
            "title": "Adapting jOOQ code generator to Rails database naming conventions",
            "date_published": "2021-08-03T00:00:00.000Z",
            "content_html": "<p>I recently updated an application which was historically built using Ruby on Rails to <a href=\"https://spring.io/projects/spring-boot\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Spring boot</a> &amp; <a href=\"https://www.jooq.org/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">jOOQ</a>.</p>\n<p>The Rails convention is to use plural table names (eg. <code>users</code>) which are auto-mapped to models with singular names (eg. <code>User</code>).</p>\n<p>JOOQ doesn&#39;t do any automatic plural-&gt;singular conversion by default, so if we directly use code-generator we end up with pojos named like <code>class Users</code> and interfaces like <code>interface IUsers</code> which are not ideal because an instance here represents a single entity&#x2F;row and so should be named singular.</p>\n<p>Fortunately this is easy to address with a custom <code>NamingStrategy</code>:</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.example;\n\n<span class=\"hljs-keyword\">import</span> org.jibx.schema.codegen.extend.DefaultNameConverter;\n<span class=\"hljs-keyword\">import</span> org.jibx.schema.codegen.extend.NameConverter;\n<span class=\"hljs-keyword\">import</span> org.jooq.codegen.DefaultGeneratorStrategy;\n<span class=\"hljs-keyword\">import</span> org.jooq.meta.Definition;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NamingStrategy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">DefaultGeneratorStrategy</span> &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">NameConverter</span> <span class=\"hljs-variable\">nameTools</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultNameConverter</span>();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getJavaClassName</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Definition definition, <span class=\"hljs-keyword\">final</span> Mode mode)</span> &#123;\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">javaClassName</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">super</span>.getJavaClassName(definition, mode);\n\n        <span class=\"hljs-comment\">// Let&#x27;s retain the plural names for TableImpl clasess</span>\n        <span class=\"hljs-keyword\">if</span> (mode == Mode.DEFAULT) <span class=\"hljs-keyword\">return</span> javaClassName;\n\n        <span class=\"hljs-comment\">// Let&#x27;s use singular names for others</span>\n        <span class=\"hljs-keyword\">return</span> nameTools.depluralize(javaClassName);\n    &#125;\n\n&#125;</code></pre>\n\n<p>Support for custom <code>GeneratorStrategy</code> implementations in JooQ offers possibility of very low level customizations of how SQL layer names are translated to java&#x2F;kotlin layer.</p>\n<p>In our case, we simply use the depluralize utility from jibx to singularize our names.</p>\n<p>We can configure our JooQ configuration to use this naming strategy:</p>\n<pre><code class=\"hljs\"><table class=\"hlcode-table\"><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">&lt;configuration&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    &lt;jdbc&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;driver&gt;${db.driverClassName}&lt;/driver&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;url&gt;${db.url}&lt;/url&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;user&gt;${db.username}&lt;/user&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;password&gt;${db.password}&lt;/password&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    &lt;/jdbc&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    &lt;generator&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;name&gt;org.jooq.codegen.JavaGenerator&lt;/name&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;!-- Other configuration options --&gt;\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;strategy&gt;\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">            &lt;name&gt;com.example.NamingStrategy&lt;/name&gt;\n</td></tr><tr style=\"border:none;background:#fffacd;\" class=\"hlcode-line  hlcode-line-highlight\" ><td style=\"border:none\" class=\"hlcode-code-cell\">        &lt;/strategy&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">    &lt;/generator&gt;\n</td></tr><tr style=\"border:none;\" class=\"hlcode-line  \" ><td style=\"border:none\" class=\"hlcode-code-cell\">&lt;/configuration&gt;\n</td></tr></table></code></pre>\n",
            "tags": [
                "Java",
                "JOOQ",
                "Ruby on Rails"
            ]
        },
        {
            "id": "https://lorefnon.me/2021/08/03/Integrating-JooQ-With-Netflix-DGS/",
            "url": "https://lorefnon.me/2021/08/03/Integrating-JooQ-With-Netflix-DGS/",
            "title": "Integrating jOOQ with Netflix DGS",
            "date_published": "2021-08-03T00:00:00.000Z",
            "content_html": "<h1 id=\"About-jOOQ-and-DGS\"><a href=\"#About-jOOQ-and-DGS\" class=\"headerlink\" title=\"About jOOQ and DGS\"></a>About jOOQ and DGS</h1><p><a href=\"jooq.org/\">jOOQ</a> is a really versatile SQL builder for JVM which I have found myself using more and more recently. My workflow usually involves evolving the database schema through <a href=\"https://www.liquibase.org/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">liquibase</a>, after which jOOQ is used to generate record classes from the DB schema.</p>\n<p>This enables type safe database access and ensures that application level types are always in sync with database schema.</p>\n<p>I recently used jOOQ with <a href=\"https://netflix.github.io/dgs/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Netflix DGS</a> to build a <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">GraphQL</a> API. Netflix DGS is a higher level abstraction over <a href=\"https://www.graphql-java.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">graphql-java</a> which makes it easy to rapidly build GraphQL APIs in a <a href=\"https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">schema-first</a> manner.</p>\n<h1 id=\"Integration-issues\"><a href=\"#Integration-issues\" class=\"headerlink\" title=\"Integration issues\"></a>Integration issues</h1><p>One issue with using them together is that both of them provide code-generation support. DGS generates kotlin data classes (or POJOs for java) from GraphQL SDL where as jOOQ generates classes from database schema.</p>\n<p>The simplest thing to do is to retrieve data from the DB using jOOQ DSL, populate them into jOOQ generated record classes and then map them to DGS generated DTO classes when returning from our services.</p>\n<p>This is quite necessary for scenarios where there is substantial difference between the properties of our record classes (which usually mirror the table columns) and the fields in the exposed GraphQL types, and jOOQ does provide a <a href=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos-with-recordmapper-provider/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">record-mapping support</a> to make this kind of mapping simpler.</p>\n<p>However, in a vast majority of scenarios, our GraphQL type fields are either same as entity properties or are resolved through dedicated data fetchers (and hence do not need corresponding properties in DTO). So this object mapping step is wasteful and can be avoided.</p>\n<h1 id=\"GraphQL-java-amp-reflection\"><a href=\"#GraphQL-java-amp-reflection\" class=\"headerlink\" title=\"GraphQL java &amp; reflection\"></a>GraphQL java &amp; reflection</h1><p>Folks familiar with graphql-java may wonder why is this even a problem ?</p>\n<p>After all graphql-java is not aware of what classes are generated by DGS at all. It simply uses reflection to map instance properties to GrpahQL fields. So when there is sufficient overlap between the two, we can simply ditch the classes generated by DGS (or skip generating them by splitting up our graphql schema file) and just use the record classes generated by jOOQ.</p>\n<p>This does work fine. Even having some extraneous fields in record class which are not present in the GraphQL type is not a problem because GraphQL resolver will cherry-pick only the fields which are defined in schema.</p>\n<p>However this becomes a problem when we want to use some of the DTOs generated by DGS and not others.</p>\n<p>Consider following example (taken from <a href=\"https://relay.dev/graphql/connections.htm\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Relay docs</a>):</p>\n<pre><code class=\"hljs graphql\">&#123;\n  user &#123;\n    id\n    name\n    friends(first: 10, after: &quot;opaqueCursor&quot;) &#123;\n      edges &#123;\n        cursor\n        node &#123;\n          id\n          name\n        &#125;\n      &#125;\n      pageInfo &#123;\n        hasNextPage\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>Our schema might look something like this:</p>\n<pre><code class=\"hljs graphql\">type User &#123;\n    id: ID!\n    name: String!\n    friends(first: Int, after: Cursor): UserConnection\n&#125;\n\nscalar Cursor\n\ntype UserConnection &#123;\n    pageInfo: PageInfo!\n    edges: [UserEdge!]\n&#125;\n\ntype UserEdge &#123;\n    cursor: Cursor!\n    node: User!\n&#125;</code></pre>\n\n<p>So now the generated data classes for <code>UserEdge</code> will be referencing the generated <code>User</code> class, and we won&#39;t be able to use it if are using a jOOQ generated <code>UsersRecord</code> instead of the <code>User</code> DTO.</p>\n<h1 id=\"typeMapping-to-rescue\"><a href=\"#typeMapping-to-rescue\" class=\"headerlink\" title=\"typeMapping to rescue\"></a>typeMapping to rescue</h1><p>Fortunately this is easy to address through support for <a href=\"https://netflix.github.io/dgs/generating-code-from-schema/#mapping-existing-types\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">typeMapping configuration</a> in DGS.</p>\n<p>We can configure jOOQ to use our record class for User instead of</p>\n<pre><code class=\"hljs groovy\">generateJava &#123;\n   typeMapping = [<span class=\"hljs-string\">&quot;User&quot;</span>: <span class=\"hljs-string\">&quot;org.jooq.generated.tables.records.UsersRecord&quot;</span>]\n&#125;</code></pre>\n\n<p>Problem solved. Now, wherever User type is needed, DGS generated DTOs will use our <code>UsersRecord</code> class. Of course, this works equally well if we want to use jOOQ generated POJOs&#x2F;interfaces or other classes defined in the application.</p>\n<h1 id=\"Caveats\"><a href=\"#Caveats\" class=\"headerlink\" title=\"Caveats\"></a>Caveats</h1><p>Only caveat here is that if the mapped class is not really structurally compatible with the the type defined in GraphQL schema, we will end up with a runtime error. Currently we don&#39;t have a statically verify this compatibility. However such bugs are easily caught in preliminary testing.</p>\n<h1 id=\"Alternatives\"><a href=\"#Alternatives\" class=\"headerlink\" title=\"Alternatives\"></a>Alternatives</h1><p>An alternative solution to address this would be to use an annotation driven approach. Annotation-heavy libraries are quite popular in the JVM ecosystem and we can use entity classes in our application which are annotated with both JPA annotations and GraphQL specific annotations (provided by <a href=\"https://github.com/leangen/graphql-spqr\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">graphql-spqr</a>, <a href=\"https://github.com/eclipse/microprofile-graphql\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">MP GraphQL</a> etc.)</p>\n<p>In this approach both the GraphQL schema and database schema can be derived from the corresponding set of annotations and we also have type safety.</p>\n<p>However I am currently not a proponent of this approach because I am not a big fan of the JPA spec., esp. the projection &amp; criteria APIs. In contrast, the jOOQ DSL is explicit, maps closely to SQL and enables me to spend more of my time in pure java&#x2F;kotlin code that I can easily step through in a debugger as opposed to an annotation based DSL.</p>\n<h1 id=\"In-praise-of-schema-first-development\"><a href=\"#In-praise-of-schema-first-development\" class=\"headerlink\" title=\"In praise of schema-first development\"></a>In praise of schema-first development</h1><p>Lastly, I prefer a schema first approach in larger teams because backend and frontend developers can agree upon the schema ahead of time and development can progress in parallel. Given a schema, it is for instance, straightforward to mock the server (and have the ui be built using that) while the real backend is being developed.</p>\n",
            "tags": [
                "Java",
                "JOOQ",
                "Ruby on Rails"
            ]
        }
    ]
}