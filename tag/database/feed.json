{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"database\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2021/12/05/extending-exposed-with-custom-operators/",
            "url": "https://lorefnon.me/2021/12/05/extending-exposed-with-custom-operators/",
            "title": "Extending Exposed with new function expressions",
            "date_published": "2021-12-05T00:00:00.000Z",
            "content_html": "<p><a href=\"https://github.com/JetBrains/Exposed\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Exposed</a> is a nice ORM for Kotlin by <a href=\"https://github.com/Tapac\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Andrey Tarashevskiy</a> from <a href=\"https://www.jetbrains.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Jetbrains</a>. Though, not an offically supported product by Jetbrains it has a good following in the Kotlin community. </p>\n<p>I recently got involved in a project using Exposed and discovered that the set of database level functions that are mapped by Exposed is quite small. However, the library makes it easy to add support for the missing functions, which is what this post outlines. </p>\n<p>Let&#39;s say we want to support product of two columns. We can support this by extending the <code>ExpressionWithColumnType</code> class.</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Product</span>&lt;<span class=\"hljs-type\">T</span>&gt;(\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> expr1: ExpressionWithColumnType&lt;T&gt;,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> expr2: ExpressionWithColumnType&lt;T&gt;\n): ExpressionWithColumnType&lt;T&gt;() &#123;\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">val</span> columnType: IColumnType\n        <span class=\"hljs-keyword\">get</span>() = expr1.columnType\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">toQueryBuilder</span><span class=\"hljs-params\">(queryBuilder: <span class=\"hljs-type\">QueryBuilder</span>)</span></span> &#123;\n        queryBuilder.append(<span class=\"hljs-string\">&quot;(&quot;</span>, expr1, <span class=\"hljs-string\">&quot;*&quot;</span>, expr2, <span class=\"hljs-string\">&quot;)&quot;</span>)\n    &#125;\n&#125;</code></pre>\n\n<p>This accepts two columns (Column class extends ExpressionWithColumnType too) of same type, and constructs the expression for multiplying these column values. </p>\n<p>While this class can be used directly, it is often convenient to also write an extension method that enables us to chain the operations similar to other exposed functions. </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-type\">&lt;T&gt;</span> ExpressionWithColumnType<span class=\"hljs-type\">&lt;T&gt;</span>.<span class=\"hljs-title\">product</span><span class=\"hljs-params\">(expr: <span class=\"hljs-type\">ExpressionWithColumnType</span>&lt;<span class=\"hljs-type\">T</span>&gt;)</span></span> =\n    Product(<span class=\"hljs-keyword\">this</span>, expr)</code></pre>\n\n<p>So now, we can easily use this in our code as: </p>\n<pre><code class=\"hljs kotlin\">DesginationTable\n    .slice(\n        DesignationTable.name,\n        DesginationTable.employeeCount.product(DesginationTable.salary)\n    )\n    .groupBy(DesignationTable.name)\n    .toList()</code></pre>\n\n<p>It is usually also convenient to use an alias to retrieve aggregated values: </p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DesignationSalaryDTO</span>(\n    <span class=\"hljs-keyword\">val</span> name: String,\n    <span class=\"hljs-keyword\">val</span> totalSalary: <span class=\"hljs-built_in\">Double</span>\n)\n\n<span class=\"hljs-keyword\">val</span> totalSalary = DesginationTable.employeeCount.product(DesginationTable.salary).alias(<span class=\"hljs-string\">&quot;total_salary&quot;</span>)\n\n<span class=\"hljs-keyword\">val</span> salaryRow DesginationTable\n    .slice(\n        DesignationTable.name, \n        <span class=\"hljs-comment\">// We can use the alias in our slice</span>\n        totalSalary\n    )\n    .groupBy(DesignationTable.name)\n    .map &#123; resultRow -&gt;\n        <span class=\"hljs-comment\">// Map results to a DTO</span>\n        DesignationSalaryDTO(\n            name = DesignationTable.name,\n            <span class=\"hljs-comment\">// We can use the same alias when retrieving the column value</span>\n            totalSalary = resultRow[totalSalary]\n        )\n    &#125;</code></pre>\n\n<p>This illustrates how we can nicely add our extension functions for operations that the library does not support, and use them in pretty much the same way as built in expression composition functions. </p>\n",
            "tags": [
                "Database",
                "Exposed"
            ]
        }
    ]
}