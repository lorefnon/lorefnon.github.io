{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"ts-sql-query\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2022/06/18/type-safe-jsonb-with-ts-sql-query/",
            "url": "https://lorefnon.me/2022/06/18/type-safe-jsonb-with-ts-sql-query/",
            "title": "Making jsonb access type-safe with a zod adapter in ts-sql-query",
            "date_published": "2022-06-18T00:00:00.000Z",
            "content_html": "<p><a href=\"https://ts-sql-query.readthedocs.io/en/stable\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">ts-sql-query</a> is a nice typescript library for typesafe database access. It goes to great lengths to ensure that if code compiles without type errors then all generated SQL is correct. Of course there are escape hatches for advanced scenarios, but having type-safety for the 90% most common usages is a huge productivity boost.</p>\n<p>Modern databases like postgres have built in json support, enabling us to store semi-structured data in a database column. While this does go against norms of traditional normalization, in practice it is immensely convenient for cases where shaping the data into tabular format is either very time consuming or simply not feasible because the entire structure of data is not known ahead of time or changes frequently.</p>\n<p>However, to be able to effectively process this data in application layer, it is often beneficial to have an application-side schema to validate this json data even if this schema is not 100% known ahead of time, evolves alongside our understanding of data or not 100% strict.</p>\n<p>In typescript, we have a multitude of options for schema validation like <a href=\"https://zod.dev/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a>, <a href=\"https://github.com/gcanti/io-ts\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">io-ts</a>, <a href=\"https://joi.dev/api/?v=17.6.0\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">joi</a> etc. In this post we primarily focus on zod because IMHO it strikes a very good balance between a user friendly API, available features and being able to extract static types from schema definitions.</p>\n<p>Whiel ts-sql-query does not have json support built-in, it supports custom types through <a href=\"https://ts-sql-query.readthedocs.io/en/stable/supported-operations/#type-adpaters\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">TypeAdapter</a>. So for our jsonb columns we can write a TypeAdapter that utilizes zod to enforce that the data coming from and going to the database conforms to our expectations.</p>\n<p>Let&#39;s say we have a zod type ChapterMedatadata:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">array</span>(),\n&#125;);\n\n<span class=\"hljs-comment\">// Extract static type</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ChapterMetadata</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>&gt;;</code></pre>\n\n<p>Following would be a type adapter that validates the incoming and outgoing json through this type:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">DefaultTypeAdapter</span>, <span class=\"hljs-title class_\">TypeAdapter</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-sql-query/TypeAdapter&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>: <span class=\"hljs-title class_\">TypeAdapter</span> = &#123;\n    <span class=\"hljs-title function_\">transformValueFromDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-comment\">// Our database adapter (postgres) is aware of jsonb and has already</span>\n            <span class=\"hljs-comment\">// parsed the JSON. So we don&#x27;t need JSON.parse. However if the dabase</span>\n            <span class=\"hljs-comment\">// didn&#x27;t have first class support for json type and</span>\n            <span class=\"hljs-comment\">// we were storing the JSON in a text field we would need to do a JSON.parse first</span>\n            <span class=\"hljs-comment\">// before calling ChapterMetadataSchema.parse</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n\n        <span class=\"hljs-comment\">// If type is not jsonb then gracefully fallback to the next adapter</span>\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueFromDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n\n    <span class=\"hljs-title function_\">transformValueToDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-comment\">// This is strictly not necessary because TS will ensure</span>\n            <span class=\"hljs-comment\">// that atleast the static type is enforced.</span>\n            <span class=\"hljs-comment\">//</span>\n            <span class=\"hljs-comment\">// However it offers aditional safety if we have some refinements</span>\n            <span class=\"hljs-comment\">// or if there is possibility of values with any type creeping in.</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n\n        <span class=\"hljs-comment\">// If type is not jsonb gracefully fallback to the next adapter</span>\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueToDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n&#125;;</code></pre>\n\n<p>Once we have the adapter in place, we can use this in our table mapping:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Table</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-sql-query/Table&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChaptersTable</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Table</span>&lt;<span class=\"hljs-title class_\">DBConnection</span>, <span class=\"hljs-string\">&quot;ChaptersTable&quot;</span>&gt; &#123;\n    id = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">autogeneratedPrimaryKey</span>(<span class=\"hljs-string\">&quot;id&quot;</span>, <span class=\"hljs-string\">&quot;int&quot;</span>);\n    metadata = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">optionalColumn</span>&lt;<span class=\"hljs-title class_\">ChapterMetadata</span>&gt;(\n        <span class=\"hljs-string\">&quot;metadata&quot;</span>,\n        <span class=\"hljs-string\">&quot;custom&quot;</span>,\n        <span class=\"hljs-string\">&quot;jsonb&quot;</span>,\n        <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>\n    );\n\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;\n        <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-string\">&quot;chapters&quot;</span>);\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> tChapters = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChaptersTable</span>();</code></pre>\n\n<p>So now whenever we try to retrieve the data from database, the value for metadata column will be validated against our schema.</p>\n<p>And because we have passed the ChapterMetadata static type as a type parameter to the column, for operations performed in typescript codebase, we get static type safety as well:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-title function_\">getConnection</span>()\n    .<span class=\"hljs-title function_\">insertInto</span>(tChapters)\n    .<span class=\"hljs-title function_\">set</span>(&#123; <span class=\"hljs-attr\">metadata</span>: &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Test&quot;</span>, <span class=\"hljs-attr\">topic</span>: <span class=\"hljs-string\">&quot;test&quot;</span> &#125; &#125;); <span class=\"hljs-comment\">// &lt;-- Static type error</span></code></pre>\n\n<p>Note that whenever we are performing type validation of data coming from a long term storage, we need to be cautious with schema evolution.</p>\n<p>Tomorrow if we update the type and add backward incompatible changes (eg. new mandatory fields), then the rows containing past data can become inaccessible.</p>\n<p>So it is better to ensure that any schema change is additive, and new fields added are optional. It is also useful to perform two step transitions where in the transition duration the schema is compatible with both previous and new shape of data (at the cost of being more relaxed than is necessary).</p>\n<p>Lastly, the above type adapter assumes that the shape of data as stored in database matches the shape of the data that the application deals with.</p>\n<p>It can sometimes be desirable to store the data in a different format than what the application deals. This could be either to facilitate ease of indexing or compaction of storage on the db side, or to use more complex data structures than json-compatible objects and arrays on the application side.</p>\n<p>While zod does not support codecs like some other libraries like io-ts, it is possible to use two different (mutually compatible) types in transformValueToDB and transformValueFromDB to convert between the two representations.</p>\n<p>A simple example of two such types can be:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z\n        .<span class=\"hljs-title function_\">string</span>()\n        .<span class=\"hljs-title function_\">array</span>()\n        .<span class=\"hljs-title function_\">transform</span>(\n            <span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n                <span class=\"hljs-comment\">// Convert the JSON array to a Set</span>\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(it)\n        ),\n    <span class=\"hljs-attr\">relevanceScores</span>: z.<span class=\"hljs-title function_\">record</span>(z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">transform</span>(\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n            <span class=\"hljs-comment\">// Convert the JSON object to a Map</span>\n            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(it))\n    ),\n&#125;);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z.<span class=\"hljs-title function_\">set</span>(z.<span class=\"hljs-title function_\">string</span>()).<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n        <span class=\"hljs-comment\">// Convert set to array</span>\n        [...it]\n    ),\n    <span class=\"hljs-attr\">relevanceScores</span>: z.<span class=\"hljs-title function_\">map</span>(z.<span class=\"hljs-title function_\">string</span>(), z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n        <span class=\"hljs-comment\">// Convert Map to object</span>\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(it.<span class=\"hljs-title function_\">entries</span>())\n    ),\n&#125;);</code></pre>\n\n<p>Now we can change our adapter to use these two separate types:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>: <span class=\"hljs-title class_\">TypeAdapter</span> = &#123;\n    <span class=\"hljs-title function_\">transformValueFromDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueFromDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n\n    <span class=\"hljs-title function_\">transformValueToDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueToDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n&#125;;</code></pre>\n\n<p>We need to make sure that these two types are always mutually compatible ie. for any valid values</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>.<span class=\"hljs-title function_\">parse</span>(value));</code></pre>\n\n<p>succeeds, and vice versa.</p>\n<p>We can use unit tests to ensure that, and we can also add witness types to validate the compatibility of corresponding static types.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Type that enforces that U is assignable to T</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ExtendsWitness</span>&lt;U <span class=\"hljs-keyword\">extends</span> T, T&gt; = U;\n\n<span class=\"hljs-comment\">// If the Input type of ChapterMetadataAppToDBSchema is not compatbile with</span>\n<span class=\"hljs-comment\">// output type of ChapterMetadataDBToAppSchema following witness will have a type error</span>\n<span class=\"hljs-keyword\">type</span> _ChapterMetadataWitness1 = <span class=\"hljs-title class_\">ExtendsWitness</span>&lt;\n    z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>&gt;,\n    <span class=\"hljs-comment\">// Extract input type from ChapterMetadataAppToDBSchema</span>\n    <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-property\">ZodType</span>&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>, infer <span class=\"hljs-title class_\">TIn</span>&gt;\n        ? <span class=\"hljs-title class_\">TIn</span>\n        : <span class=\"hljs-built_in\">never</span>\n&gt;;</code></pre>\n\n<p>and similarly the other way round.</p>\n",
            "tags": [
                "typescript",
                "zod",
                "ts-sql-query"
            ]
        }
    ]
}