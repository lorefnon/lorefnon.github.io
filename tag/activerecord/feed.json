{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"activerecord\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2014/07/27/optimizing-sti-columns.html",
            "url": "https://lorefnon.me/2014/07/27/optimizing-sti-columns.html",
            "title": "Optimizing space taken by type column in Rails STI",
            "date_published": "2014-07-26T18:30:00.000Z",
            "content_html": "<p>The <a href=\"http://api.rubyonrails.org/classes/ActiveRecord/Base.html#label-Single+table+inheritance\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Single Table Inheritance</a>\nfacility in Rails is quite awesome in that it is simple, minimal and easy to understand.\nHowever that simplicity comes with a small price - the type column stores the full name of the relevant class as a string.\nThis becomes especially unweildy if you scope your models inside a module.</p>\n<p>Let us illustrate this with an example:</p>\n<p>Let us say, we have a database of institutions. For non profit and commercial institutions we have two subclasses of <code>Institution::Base</code> namely, <code>Institution::NonProfit</code>, <code>Institution::Commercial</code>.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#app/models/institution.rb</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-title\">Institution</span></span>\n  def <span class=\"hljs-keyword\">self</span>.table_name_prefix\n    <span class=\"hljs-string\">&#x27;institution_&#x27;</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-comment\"># app/models/institution/base.rb</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Institution::Base</span> &lt; ActiveRecord::Base</span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-comment\">#app/models/institution/non_profit.rb</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Institution::NonProfit</span> &lt; Institution::Base</span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-comment\">#app/models/institution/commercial.rb</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Institution::Commercial</span> &lt; Institution::Base</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>We deliberately keep the schema simple:</p>\n<pre><code class=\"hljs ruby\">create_table <span class=\"hljs-string\">&quot;institution_bases&quot;</span>, <span class=\"hljs-symbol\">force:</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|t|</span>\n    t.string   <span class=\"hljs-string\">&quot;name&quot;</span>\n    t.string   <span class=\"hljs-string\">&quot;type&quot;</span>\n    t.datetime <span class=\"hljs-string\">&quot;created_at&quot;</span>\n    t.datetime <span class=\"hljs-string\">&quot;updated_at&quot;</span>\n <span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>The subclasses simply reuse the table and Rails distinguishes between them using the type column. If we  try to store some sample entries, we would notice that the value stored in type field contains the fully namespaces class name: <code>Institution::NonProfit</code>, <code>Institution::Commercial</code> etc.</p>\n<p>Since we know that our application will not store models from other namespace in this table, the extra space taken by the module name is wasteful. In fact storing the name in its entirety is wasteful. So this post highlights a simple approach to minimise the space taken by type column without sacrificing the ease of use of STI in rails.</p>\n<p>It turns out we can override the methods Rails uses to convert the table name to class name and vice versa:</p>\n<p>The relevant methods are <code>find_sti_class</code> which is responsible for the translating the value stored in the type column to the respective ActiveRecord model and <code>sti_name</code> which is responsible for retriving the value stored in type column given an ActiveRecord subclass.</p>\n<p>So we override the default implementations to the following:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Institution::Base</span> &lt; ActiveRecord::Base</span>\n\n  ALLOWED_CLASSES = <span class=\"hljs-string\">%w[Institution::NonProfit Institution::Commercial]</span>\n\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> &lt;&lt; self</span>\n\n    def find_sti_class type_name\n      idx = type_name.to_i\n      <span class=\"hljs-keyword\">super</span> <span class=\"hljs-keyword\">if</span> idx == <span class=\"hljs-number\">0</span>\n      ALLOWED_CLASSES[idx-<span class=\"hljs-number\">1</span>].constantize\n    <span class=\"hljs-keyword\">rescue</span> NameError, TypeError\n      <span class=\"hljs-keyword\">super</span>\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sti_name</span></span>\n      idx = ALLOWED_CLASSES.index(<span class=\"hljs-keyword\">self</span>.name)\n      <span class=\"hljs-keyword\">if</span> idx.<span class=\"hljs-literal\">nil</span>?\n        <span class=\"hljs-keyword\">super</span>\n      <span class=\"hljs-keyword\">else</span>\n        idx + <span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>Once we have done this the STI subsystem of ActiveRecord will the use the <code>ALLOWED_CLASSES</code> to infer the name Institution classes using the index stored in the database column.</p>\n<p>What is particularly nice is that if have any existing data, we don&#39;t end up getting\nany errors when trying to save or retrieve them since we delegate to default implementations. Although it would be a better option to write a migration to change the type column to integer.</p>\n<p>The eagle eyed among us might have noticed we are offsetting the index in the <code>ALLOWED_CLASSES</code> index by 1. This is a basic precaution because calling <code>to_i</code> on a string that is not a numeric string returns <code>0</code> instead of raising an error. So delegating to default implementation incase of zero value allows us to retain legacy compatibility.</p>\n<p>You might want to ask why the array ALLOWED_CLASS_NAMES is a string array rather than an actual array of classes. Having an array of classes leads to RecursiveDependency errors while autoloading when fetching the entries from databases.</p>\n<p>While this is nice and good, this functionality is generic and doesn&#39;t really belong to the <code>Institution::Base</code> class. What if we need another module tomorrow which is unreleated but needs the same functionality?</p>\n<p>So in the spirit of reusability and separation of concerns we create a <code>concern</code> for this:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-title\">OptimallyInheritable</span></span>\n  extend ActiveSupport::Concern\n\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-title\">ClassMethods</span></span>\n    def support_sti_for cls_list\n      <span class=\"hljs-variable\">@sti_cls_list</span> = []\n      <span class=\"hljs-variable\">@sti_cls_list</span> += cls_list\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sti_cls_list</span></span>\n      <span class=\"hljs-variable\">@sti_cls</span>_list\n    <span class=\"hljs-keyword\">end</span>\n\n    def find_sti_class type_name\n      idx = type_name.to_i\n      <span class=\"hljs-keyword\">super</span> <span class=\"hljs-keyword\">if</span> idx == <span class=\"hljs-number\">0</span>\n      sti_cls_list[type_name.to_i-<span class=\"hljs-number\">1</span>].constantize\n    <span class=\"hljs-keyword\">rescue</span> NameError, TypeError\n      <span class=\"hljs-keyword\">super</span>\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sti_name</span></span>\n      idx = sti_cls_list.index(<span class=\"hljs-keyword\">self</span>.name)\n      <span class=\"hljs-keyword\">if</span> idx.<span class=\"hljs-literal\">nil</span>?\n        <span class=\"hljs-keyword\">super</span>\n      <span class=\"hljs-keyword\">else</span>\n        idx + <span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>And our <code>Institution::Base</code> class just reduces to:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Institution::Base</span> &lt; ActiveRecord::Base</span>\n  <span class=\"hljs-keyword\">include</span> OptimallyInheritable\n  support_sti_for <span class=\"hljs-string\">%w[Institution::NonProfit Institution::Commercial]</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>All seems kosher, so we take our implementation for a test drive:</p>\n<pre><code>&gt; Institution::Base.all\nInstitution::Base Load (0.4ms)  SELECT `institution_bases`.* FROM `institution_bases`\n=&gt; #&lt;ActiveRecord::Relation [#&lt;Institution::Commercial id: 3, name: &quot;loremipsum&quot;, type: &quot;2&quot;, created_at: &quot;2014-07-17 12:27:26&quot;, updated_at: &quot;2014-07-17 12:27:26&quot;&gt;]&gt;\n</code></pre>\n<p>While laoding instances of base class works well, we run into issues when we try to load all commercial\ninstitutions:</p>\n<pre><code>2.1.2 :005 &gt; Institution::Commercial.all\nNoMethodError: undefined method `index&#39; for nil:NilClass\n               from /Users/lorefnon/Workspace/sample/app/models/concerns/optimally_inheritable.rb:24:in `sti_name&#39;\n               from /Users/lorefnon/.rvm/gems/ruby-2.1.2@sample/gems/activerecord-4.1.4/lib/active_record/inheritance.rb:170:in `block in type_condition&#39;\n               from /Users/lorefnon/.rvm/gems/ruby-2.1.2@sample/gems/activerecord-4.1.4/lib/active_record/inheritance.rb:170:in `map&#39;\n               from /Users/lorefnon/.rvm/gems/ruby-2.1.2@sample/gems/activerecord-4.1.4/lib/active_record/inheritance.rb:170:in `type_condition&#39;\n               from /Users/lorefnon/.rvm/gems/ruby-2.1.2@sample/gems/activerecord-4.1.4/lib/active_record/core.rb:170:in `relation&#39;\n</code></pre>\n<p>The problem is obvious : the variable <code>sti_class_list</code> is not available in subclasses.</p>\n<p>So we rectify our solution:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sti_cls_list</span></span>\n  <span class=\"hljs-keyword\">if</span> superclass.respond_to? <span class=\"hljs-symbol\">:sti_cls_list</span>\n    superclass.sti_cls_list\n  <span class=\"hljs-keyword\">else</span>\n    <span class=\"hljs-variable\">@sti_cls</span>_list\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>This resolves the aforementioned issues.</p>\n<p>Now that we have reached the end of the post, it would be a good time to highlight the drawbacks of our approach:</p>\n<ol>\n<li>Firstly, The array passed to <code>support_sti_for</code> function will have to be kept in sync with the class names, if the name of any model class changes in future.</li>\n<li>Secondly, While it is safe to add new entries to supported classes, their order can not be arbitrarily changed without running a data correction script first.</li>\n</ol>\n<p>This concludes our post. The full source code is available at <a href=\"https://github.com/lorefnon/sti_optimization_demo.git\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Github</a>. As always, any criticism or feedback is welcome.</p>\n",
            "tags": [
                "Ruby",
                "Rails",
                "ActiveRecord"
            ]
        }
    ]
}