{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"go\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2022/09/04/getting-started-with-jet-query-builder-for-golang/",
            "url": "https://lorefnon.me/2022/09/04/getting-started-with-jet-query-builder-for-golang/",
            "title": "Getting started with Jet Query builder for Go",
            "date_published": "2022-09-04T00:00:00.000Z",
            "content_html": "<p>I was recently looking for a good query builder for a go application I am prototyping, and settled on <a href=\"https://github.com/go-jet/jet\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Jet</a>. Jet has a nice <a href=\"https://github.com/go-jet/jet/wiki\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">wiki</a>, but limited introductory material as of this writing, so this post is an attempt to collect a set of small recipies to help you get started with it quicker.</p>\n<h2 id=\"Why-Jet\"><a href=\"#Why-Jet\" class=\"headerlink\" title=\"Why Jet ?\"></a>Why Jet ?</h2><p>Usually larger applications tend to adopt fully featured ORMs early on, where as smaller micro-services often eschew the complexity that comes with a full ORM and directly use the low level database adapters.</p>\n<p>Query builders like jet sit somewhere between the two in the abstraction ladder. </p>\n<p>Unlike a full ORM it doesn&#39;t have features like dirty tracking, model lifecycle hooks etc. </p>\n<p>Also unlike directly using a database driver, it provides a type-safe API to construct SQL queries which I find much more ergonomic and less error-prone than raw parameterized queries or (ugh) constructing complex sql with string interpolations.</p>\n<p>Jet fits a sweet spot for me, because: </p>\n<ol>\n<li>It is not overly opinionated around how database should be accessed.</li>\n<li>Whatever you can do with SQL, you can also do with Jet</li>\n<li>It is performant, very little overhead over direct SQL</li>\n<li>It is type-safe - no ugly string interpolations, no SQL syntax errors in corner cases.</li>\n<li>The API closely matches the SQL syntax - so less learning curve is required</li>\n</ol>\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use ?\"></a>How to use ?</h2><p>Jet is easy to get started with. It is designed to work with the <code>database/sql</code> package in go stdlib, and only offers a query builder. The database&#x2F;sql package is used for actually executing the queries on the database.</p>\n<p>In this post we will use a sqlite, but jet offers support for most mainstream databases.</p>\n<h3 id=\"Configuring-the-codegenerator\"><a href=\"#Configuring-the-codegenerator\" class=\"headerlink\" title=\"Configuring the codegenerator\"></a>Configuring the codegenerator</h3><p>Jet offers what is called a database-first approach. In this approach, you update your database first (a migration system is recommended) and then generate code from the database for all your tables. </p>\n<p>This ensures that the table mapping code is always up-to-date and you don&#39;t need to specify every column being added twice - once when updating the database, and once in application code. </p>\n<p>Let us say we have following sql tables defined in test.sqlite3: </p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span>\n  notebook (id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">36</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key, title <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">500</span>));\n\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span>\n  note (\n    id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">36</span>) <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key,\n    title <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">500</span>),\n    notebook_id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">36</span>) <span class=\"hljs-keyword\">references</span> notebook (id) <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">delete</span> cascade <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> restrict\n  );</code></pre>\n\n<p>To generate the code, we&#39;ll first need to install the jet cli. We will also need to ensure that the specific database drivers we need are enabled through build tags: </p>\n<pre><code class=\"hljs plaintext\">go install -tags &#x27;sqlite3&#x27; github.com/go-jet/jet/v2/cmd/jet@latest</code></pre>\n\n<p>Note that you will need to change the tags if you are using another database.  Also if you are using sqlite, and need to use some of the sqlite extensions, you&#39;ll need additional build tags for those too, for example: </p>\n<pre><code class=\"hljs plaintext\">go install -tags &#x27;json1 fts5 sqlite3&#x27; github.com/go-jet/jet/v2/cmd/jet@latest</code></pre>\n\n<p>Inside a go project, we can generate the jet mapper code for this database using a command like: </p>\n<pre><code class=\"hljs plaintext\">jet -source=sqlite -dsn=&quot;/tmp/test.sqlite3&quot; -path=./gen/jet</code></pre>\n\n<p>if you use a migration system like dbmate, go-migrate or atlas, you&#39;d typically want to exclude the tables used only for migration bookkeeping.</p>\n<pre><code class=\"hljs plaintext\">jet -source=sqlite -dsn=&quot;/tmp/test.sqlite3&quot; -path=./gen/jet -ignore-tables=schema_migrations</code></pre>\n\n<p>Ok, so now let&#39;s look at the generated files: For every table we have a table mapper file and model file. For example for notebook we have the following table mapper file:</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// Code generated by go-jet DO NOT EDIT.</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// WARNING: Changes to this file may cause incorrect behavior</span>\n<span class=\"hljs-comment\">// and will be lost if the code is regenerated</span>\n<span class=\"hljs-comment\">//</span>\n\n<span class=\"hljs-keyword\">package</span> table\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;github.com/go-jet/jet/v2/sqlite&quot;</span>\n)\n\n<span class=\"hljs-keyword\">var</span> Notebook = newNotebookTable(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;notebook&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>)\n\n<span class=\"hljs-keyword\">type</span> notebookTable <span class=\"hljs-keyword\">struct</span> &#123;\n\tsqlite.Table\n\n\t<span class=\"hljs-comment\">//Columns</span>\n\tID    sqlite.ColumnString\n\tTitle sqlite.ColumnString\n\n\tAllColumns     sqlite.ColumnList\n\tMutableColumns sqlite.ColumnList\n&#125;\n\n<span class=\"hljs-keyword\">type</span> NotebookTable <span class=\"hljs-keyword\">struct</span> &#123;\n\tnotebookTable\n\n\tEXCLUDED notebookTable\n&#125;\n\n<span class=\"hljs-comment\">// AS creates new NotebookTable with assigned alias</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> AS(alias <span class=\"hljs-type\">string</span>) *NotebookTable &#123;\n\t<span class=\"hljs-keyword\">return</span> newNotebookTable(a.SchemaName(), a.TableName(), alias)\n&#125;\n\n<span class=\"hljs-comment\">// Schema creates new NotebookTable with assigned schema name</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> FromSchema(schemaName <span class=\"hljs-type\">string</span>) *NotebookTable &#123;\n\t<span class=\"hljs-keyword\">return</span> newNotebookTable(schemaName, a.TableName(), a.Alias())\n&#125;\n\n<span class=\"hljs-comment\">// WithPrefix creates new NotebookTable with assigned table prefix</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> WithPrefix(prefix <span class=\"hljs-type\">string</span>) *NotebookTable &#123;\n\t<span class=\"hljs-keyword\">return</span> newNotebookTable(a.SchemaName(), prefix+a.TableName(), a.TableName())\n&#125;\n\n<span class=\"hljs-comment\">// WithSuffix creates new NotebookTable with assigned table suffix</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a NotebookTable)</span></span> WithSuffix(suffix <span class=\"hljs-type\">string</span>) *NotebookTable &#123;\n\t<span class=\"hljs-keyword\">return</span> newNotebookTable(a.SchemaName(), a.TableName()+suffix, a.TableName())\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newNotebookTable</span><span class=\"hljs-params\">(schemaName, tableName, alias <span class=\"hljs-type\">string</span>)</span></span> *NotebookTable &#123;\n\t<span class=\"hljs-keyword\">return</span> &amp;NotebookTable&#123;\n\t\tnotebookTable: newNotebookTableImpl(schemaName, tableName, alias),\n\t\tEXCLUDED:      newNotebookTableImpl(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;excluded&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>),\n\t&#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newNotebookTableImpl</span><span class=\"hljs-params\">(schemaName, tableName, alias <span class=\"hljs-type\">string</span>)</span></span> notebookTable &#123;\n\t<span class=\"hljs-keyword\">var</span> (\n\t\tIDColumn       = sqlite.StringColumn(<span class=\"hljs-string\">&quot;id&quot;</span>)\n\t\tTitleColumn    = sqlite.StringColumn(<span class=\"hljs-string\">&quot;title&quot;</span>)\n\t\tallColumns     = sqlite.ColumnList&#123;IDColumn, TitleColumn&#125;\n\t\tmutableColumns = sqlite.ColumnList&#123;TitleColumn&#125;\n\t)\n\n\t<span class=\"hljs-keyword\">return</span> notebookTable&#123;\n\t\tTable: sqlite.NewTable(schemaName, tableName, alias, allColumns...),\n\n\t\t<span class=\"hljs-comment\">//Columns</span>\n\t\tID:    IDColumn,\n\t\tTitle: TitleColumn,\n\n\t\tAllColumns:     allColumns,\n\t\tMutableColumns: mutableColumns,\n\t&#125;\n&#125;</code></pre>\n\n<p>This file initializes the specific table objects for constructing SQL queries.</p>\n<p>We also have a model file which is a simple go struct representing a row in a table: </p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// Code generated by go-jet DO NOT EDIT.</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// WARNING: Changes to this file may cause incorrect behavior</span>\n<span class=\"hljs-comment\">// and will be lost if the code is regenerated</span>\n<span class=\"hljs-comment\">//</span>\n\n<span class=\"hljs-keyword\">package</span> model\n\n<span class=\"hljs-keyword\">type</span> Notebook <span class=\"hljs-keyword\">struct</span> &#123;\n\tID    <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`sql:&quot;primary_key&quot;`</span>\n\tTitle *<span class=\"hljs-type\">string</span>\n&#125;</code></pre>\n\n<p>We will have this pair generated for each table in our db. </p>\n<h2 id=\"Executing-queries\"><a href=\"#Executing-queries\" class=\"headerlink\" title=\"Executing queries\"></a>Executing queries</h2><p>Now that we have our code generated, we can use the generated API to query our database. </p>\n<p>Jet&#39;s api closely matches the SQL syntax. So to fetch a note with known title we can do something like: </p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">import</span> (\n\tm <span class=\"hljs-string\">&quot;example.com/rts/gen/jet/model&quot;</span>\n\tt <span class=\"hljs-string\">&quot;example.com/rts/gen/jet/table&quot;</span>\n\tjet <span class=\"hljs-string\">&quot;github.com/go-jet/jet/v2/sqlite&quot;</span>\n)\n\nquery := t.Note.\n    SELECT(t.Notebook.AllColumns).\n    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>))</code></pre>\n\n<p>Note that this just creates the query. To actually execute it, we need a sql.DB instance. This would be created through the database&#x2F;sql package in go stdlib and is not jet specific. </p>\n<p>For SQLite all we need is the path to the database. For other database we can pass connection strings.</p>\n<pre><code class=\"hljs go\">db, err := sql.Open(<span class=\"hljs-string\">&quot;sqlite3&quot;</span>, dbFilePath)</code></pre>\n\n<p>Now we can run the query through the db instance and map the rows to our generated model structs: </p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> notebooks []m.Notebook\n\nerr := t.Notebook.\n    SELECT(t.Notebook.AllColumns).\n    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>)).\n    Query(db, &amp;notebooks)</code></pre>\n\n<p>If the query succeeds our notebooks slice will be populated with the fetched rows.</p>\n<p>Note that we didn&#39;t have to deal with untyped data at any point. </p>\n<p>We are also not restricted to using the generated model types. The generated model types are provided as a convenience for common crud operations, but we will often need to define custom types when fetching subset of columns or when fetching data from multiple tables. </p>\n<p>Let&#39;s say we want to fetch not only the notebook, but all associated notes. To represent a note along with member notes, we can define following struct which composes the generated models:</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> NotebookWithNotes <span class=\"hljs-keyword\">struct</span> &#123;\n    m.Notebook,\n    Notes []m.Note\n&#125;</code></pre>\n\n<p>and use that in our query:</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> notebooks []m.NotebookWithNotes\n\nerr := t.Notebook.\n    INNER_JOIN(t.Note, t.Note.NotebookID.EQ(t.Notebook.ID))\n    SELECT(t.Notebook.AllColumns).\n    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>)).\n    Query(db, &amp;notebooks)</code></pre>\n\n<p>The join syntax is pretty similar to what we would have expected from SQL. Also we didn&#39;t have to do anything special here to support mapping the flattened rows to hierarchical model. jet is able to automatically identify the Notebook fields from embedded struct and the Note fields in the member slice and populate them all from the rows in database. </p>\n<h2 id=\"Integration-with-context-propagation\"><a href=\"#Integration-with-context-propagation\" class=\"headerlink\" title=\"Integration with context propagation\"></a>Integration with context propagation</h2><p>Almost all web frameworks integrate with Go&#39;s context propagation system, and it is useful to take advantage of it so that when the context gets cancelled, unnecessary operations can be avoided in the backend. <a href=\"https://www.digitalocean.com/community/tutorials/how-to-use-contexts-in-go\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">This DO post</a> goes into more details about the context mechanism in go. </p>\n<p>jet makes it easier to integrate this mechanism. If we have a context instance at our disposal (likely coming as an argument in our request handler from a web framework), we can pass that to the <code>QueryContext</code> function instead of using the <code>Query</code> function as above:</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> notebooks []m.NotebookWithNotes\n\nerr := t.Notebook.\n    INNER_JOIN(t.Note, t.Note.NotebookID.EQ(t.Notebook.ID))\n    SELECT(t.Notebook.AllColumns).\n    WHERE(t.Notebook.Title.EQ(<span class=\"hljs-string\">&quot;Test&quot;</span>)).\n    Query(db, &amp;notebooks)</code></pre>\n\n<h2 id=\"Query-Logging\"><a href=\"#Query-Logging\" class=\"headerlink\" title=\"Query Logging\"></a>Query Logging</h2><p>It is clear now that jet enables us to construct complex queries dynamically in our application. It is often useful to log these queries in development so that we can see what exactly is getting executed. This is also useful for DBA audits.</p>\n<p>To make this possible, jet provides a <code>SetQueryLogger</code> API, which can be used to log operations through any logging library: </p>\n<pre><code class=\"hljs go\">jet.SetQueryLogger(<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, info jet.QueryInfo)</span></span> &#123;\n\tquery, args := info.Statement.Sql()\n\tzerolog.Debug().\n\t\tInt64(<span class=\"hljs-string\">&quot;DurationMS&quot;</span>, info.Duration.Milliseconds()).\n\t\tMsgf(<span class=\"hljs-string\">&quot;SQL Query: SQL: %s\\nArgs: %+v&quot;</span>, query, args)\n&#125;)</code></pre>\n\n<p>Above example uses zerolog, but we are free to use any logging library available for go.</p>\n<h2 id=\"Insert-x2F-Update\"><a href=\"#Insert-x2F-Update\" class=\"headerlink\" title=\"Insert&#x2F;Update\"></a>Insert&#x2F;Update</h2><p>Insert&#x2F;update APIs are also pretty similar to what we&#39;d expect from SQL. We can pass raw values or make use of model structs generated for us (recommended). Following example illustrates the latter approach for insertion: </p>\n<pre><code class=\"hljs go\">_, err := t.Notebook.\n\tINSERT(t.Notebook.AllColumns).\n\tMODEL(&amp;m.Notebook&#123;\n\t\tTitle: &amp;title,\n\t&#125;).\n\tExec(db)</code></pre>\n\n<p>The wiki goes into more detail about available APIs, but it is particularly notable that jet has good support for on conflict update APIs which are often useful for preventing get-check-insert race-conditions: </p>\n<pre><code class=\"hljs go\">_, err := t.Notebook.\n\tINSERT(t.Notebook.AllColumns).\n\tMODEL(&amp;m.Notebook&#123;\n\t\tID:    someId,\n\t\tTitle: &amp;title,\n\t&#125;).\n\tON_CONFLICT(t.Notebook.ID).\n\tDO_UPDATE(jet.SET(t.Notebook.Title.SET(t.Notebook.EXCLUDED.Title))).\n\tExec(db)</code></pre>\n\n<p>In contrast, if did a select to check whether a notebook exists, and issued an insert if it didn&#39;t, the insert could still fail because a notebook could have been inserted in the meanwhile.</p>\n<h2 id=\"Subqueries\"><a href=\"#Subqueries\" class=\"headerlink\" title=\"Subqueries\"></a>Subqueries</h2><p>As we may expect by now, jet has good support for subqueries too. </p>\n<pre><code class=\"hljs go\">_, err = t.Note.DELETE().\n\tWHERE(\n\t\tt.Note.ID.IN(\n\t\t\tt.Note.LEFT_JOIN(t.NoteFile, t.NoteFile.NoteID.EQ(t.Note.ID)).\n\t\t\t\tSELECT(t.Note.ID).\n\t\t\t\tWHERE(t.Note.NotebookID.EQ(jet.String(notebookId)).\n\t\t\t\t\tAND(t.NoteFile.ID.IS_NULL())),\n\t\t),\n\t).\n\tExecContext(ctx, store.db)</code></pre>\n\n<p>Hopefully this provides a high-level overview that can jumpstart your go project that needs database access.</p>\n<p>This post has, however, just scratched the surface of what is possible with jet, and the aforementioned <a href=\"https://github.com/go-jet/jet/wiki\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">jet wiki</a> goes into a lot more detail.</p>\n",
            "tags": [
                "go",
                "golang",
                "jet",
                "sql"
            ]
        }
    ]
}