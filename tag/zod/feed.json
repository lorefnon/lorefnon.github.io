{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"zod\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2022/06/25/generating-api-docs-for-zod-types/",
            "url": "https://lorefnon.me/2022/06/25/generating-api-docs-for-zod-types/",
            "title": "Generating API docs for zod-types",
            "date_published": "2022-06-25T00:00:00.000Z",
            "content_html": "<p>I often like to use <a href=\"https://github.com/colinhacks/zod\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a> for validating user provided options in the public API in typescript projects. Zod offers a really nice validation &amp; type inference support and it is nice to be able to fail early for invalid options even if consumer is not using typescript.</p>\n<p>Generating API documentation is a bit of trouble though, for these types. <a href=\"https://typedoc.org/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Typedoc</a> is a nice documentation generator I frequently use, but it does not have any specialized zod support and works best when types are defined through normal typescript interfaces.</p>\n<p>So what do we do ? </p>\n<p>Interestingly, typescript is able to propagate comments through inheritance hierarchy and mapped types.</p>\n<p>So if we have a zod-type as follows: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-comment\">/** Full name of user */</span>\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>()\n&#125;)</code></pre>\n\n<p>and later define an interface that extends the type inferred from this: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">User</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-title class_\">TypeOf</span>&lt;typeof <span class=\"hljs-title class_\">UserSchema</span>&gt; &#123;&#125;</code></pre>\n\n<p>The generated documentation of User will contain the comments for name property.</p>\n<p>This unfortunately works only for Object types as long as we don&#39;t introduce any unions and intersections - any base type of an interface must have statically known members. This also doesn&#39;t work well for nested object types as typedoc will pick only the types at top level.</p>\n<p>For more complex types, a simple workaround is to extract interfaces for constituent types and link them in the documentation. </p>\n<p>So instead of:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserDetailsSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">profile</span>: z.<span class=\"hljs-title function_\">object</span>(&#123;\n        <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>()\n    &#125;).<span class=\"hljs-title function_\">nullish</span>()\n&#125;);</code></pre>\n\n<p>We&#39;d write: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ProfileSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-comment\">/** Full name of user */</span>\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>()\n&#125;);\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Profile</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-title class_\">TypeOf</span>&lt;typeof <span class=\"hljs-title class_\">ProfileSchema</span>&gt; &#123;&#125;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserDetailsSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-comment\">/** See &#123;<span class=\"hljs-doctag\">@link</span> Profile&#125; */</span>\n    <span class=\"hljs-attr\">profile</span>: <span class=\"hljs-title class_\">Profile</span>.<span class=\"hljs-title function_\">nullish</span>()\n&#125;)\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserDetails</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-title class_\">TypeOf</span>&lt;typeof <span class=\"hljs-title class_\">UserDetailsSchema</span>&gt; &#123;&#125;</code></pre>\n\n<p>This increases the boilerplate a bit, but is otherwise quite practical.</p>\n",
            "tags": [
                "typescript",
                "zod"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/06/18/type-safe-event-handling-with-zod-and-ts-pattern/",
            "url": "https://lorefnon.me/2022/06/18/type-safe-event-handling-with-zod-and-ts-pattern/",
            "title": "Type-safe event handling in Typescript with zod and ts-match",
            "date_published": "2022-06-18T00:00:00.000Z",
            "content_html": "<h1 id=\"Event-handling\"><a href=\"#Event-handling\" class=\"headerlink\" title=\"Event handling\"></a>Event handling</h1><p>It is no surprise to anyone that event handling is bread and butter in javascript. However, often we receive several types of events from an event source which makes handling them in a type-safe manner harder. Eg. if we are consuming websocket events on the backend we may write something like: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> ws <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ws&quot;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>()\n\n<span class=\"hljs-keyword\">const</span> server = app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>)\n\n<span class=\"hljs-keyword\">const</span> wss = <span class=\"hljs-keyword\">new</span> ws.<span class=\"hljs-title class_\">Server</span>(&#123; server &#125;)\n\nwss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;connection&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ws: ws.WebSocket</span>) =&gt;</span> &#123;\n    ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data); \n               ^\n               <span class=\"hljs-string\">`----- any :(</span>\n<span class=\"hljs-string\">    &#125;)</span>\n<span class=\"hljs-string\">&#125;)</span></code></pre>\n\n<p>Similarly we could be receiving a message from a different window&#x2F;frame through postMessage, or another peer over a webrtc data channel, the problem remains the same: After receiving the data we need to disambiguate it into one of the multiple possible types of messages and branch out the handling logic from there.</p>\n<p>The most basic way would be to write a <a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">type-guard</a> for each possible type.</p>\n<p>Typescript offers flow-sensitive typing so once we have established in a branch that a value is of a particular type, we do need any extra casts. </p>\n<p>So we could write something like this: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">PostDetails</span> &#123;\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-comment\">// Types for our events:</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">CreatePost</span> &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;CreatePost&quot;</span>,\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetails</span>\n&#125;\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UpdatePost</span> &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>,\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetails</span>\n&#125;\n\n<span class=\"hljs-comment\">// Type-guards for different message types</span>\n<span class=\"hljs-keyword\">const</span> isCreatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt; event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;CreatePost&quot;</span>\n<span class=\"hljs-keyword\">const</span> isUpdatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt; event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>\n\n<span class=\"hljs-comment\">// Later in our message receiver: </span>\n\nws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data); \n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isCreatePost</span>(parsed)) &#123;\n        ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleCreatePost</span>(parsed))\n        <span class=\"hljs-comment\">//                       ^</span>\n        <span class=\"hljs-comment\">//                       `---- type of parsed is CreatePost in this branch</span>\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isUpdatePost</span>(parsed)) &#123;\n        ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleUpdatePost</span>(parsed))\n        <span class=\"hljs-comment\">//                        ^</span>\n        <span class=\"hljs-comment\">//                         `---- type of parsed is UpdatePost in this branch</span>\n    &#125;\n    <span class=\"hljs-comment\">// ....</span>\n&#125;)</code></pre>\n\n<p>This works, but it is quite a bit of boilerplate to discriminate&#x2F;disambiguate between different possible types. This boilerpate is also repetitive if we adopt a convention that we will always discriminate the types based on a <code>type</code> attribute which all the events will have. </p>\n<p>Other issue is that we are trusting the rest of the shape of the data based on the type attribute. Our type-guards (isCreatePost, isUpdatePost etc.) just check for the type property - and assumes that rest of the properties are as expected. If the websocket client sends an invalid object like <code>&#123; type: &quot;CreatePost&quot; &#125;</code> (no data) we will get a runtime error which may surface deeper inside the handling logic with a confusing stack trace. </p>\n<p>When we are receiving data over a network boundary or from a persisted store, it is generally safer to validate the complete payload at the boundary itself (which is our message receiver function in this example) and fail early with a clean error.</p>\n<p>We could write our type-guard to be more defensive like: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> isCreatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt; &#123;\n    <span class=\"hljs-keyword\">return</span> event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;CreatePost&quot;</span> &amp;&amp;\n        <span class=\"hljs-keyword\">typeof</span> event.<span class=\"hljs-property\">data</span> === <span class=\"hljs-string\">&quot;object&quot;</span> &amp;&amp;\n        <span class=\"hljs-keyword\">typeof</span> event.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">title</span> === <span class=\"hljs-string\">&quot;string&quot;</span> &amp;&amp;\n        <span class=\"hljs-keyword\">typeof</span> event.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">description</span> === <span class=\"hljs-string\">&quot;string&quot;</span>;\n&#125;</code></pre>\n\n<p>But this is now a ton of additional work. </p>\n<p>This is also error prone because tomorrow if we add another field in PostDetails we will also need to update all these type-guards to accomodate the same. They have to kept in sync manually with no help from type-checker whatsoever.</p>\n<p>Fortunately, we have libraries to simplify this validation logic for us. One such library is <a href=\"https://github.com/colinhacks/zod\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a> which is what I currently use in my production applications.</p>\n<p>With zod we can define the shape of our events through zod&#39;s API: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> zod <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">PostDetailsSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">title</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">description</span>: z.<span class=\"hljs-title function_\">string</span>()\n&#125;);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">CreatePostSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;CreatePost&quot;</span>),\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n&#125;);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UpdatePostSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;UpdatePost&quot;</span>),\n    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>.<span class=\"hljs-title function_\">partial</span>()\n&#125;)</code></pre>\n\n<p>The benefit of defining these schema objects, is that we are able to perform runtime validation of unknown data.</p>\n<p>So our isCreatePost type-guard can be written as: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> isCreatePost = (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-built_in\">any</span>): event is <span class=\"hljs-title class_\">CreatePost</span> =&gt;\n    <span class=\"hljs-title class_\">CreatePostSchema</span>.<span class=\"hljs-title function_\">safeParse</span>(event).<span class=\"hljs-property\">success</span></code></pre>\n\n<p>We also don&#39;t have to manually define the typescript interfaces for <code>CreatePost</code>, <code>UpdatePost</code> etc. ourselves. They can instead be inferred from the Schema objects. </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">CreatePost</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">CreatePostSchema</span>&gt;;\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">UpdatePost</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">UpdatePostSchema</span>&gt;;</code></pre>\n\n<p>The above approach of discriminating between multiple types using a shared property is very common in practice, and we call union of such types as discriminated unions. </p>\n<p>Zod has built in support for discriminated unions, and we can define an EventSchema as follows: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">//                                          ,---- Property based on which we will discriminate</span>\n<span class=\"hljs-comment\">//                                         V           the members of our union type</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EventSchema</span> = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(<span class=\"hljs-string\">&quot;type&quot;</span>, [\n    <span class=\"hljs-title class_\">CreatePostSchema</span>,\n    <span class=\"hljs-title class_\">UpdatePostSchema</span>\n])</code></pre>\n\n<p>Often, we won&#39;t define the individual members separately: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EventSchema</span> = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(<span class=\"hljs-string\">&quot;type&quot;</span>, [\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;CreatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n   &#125;),\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;UpdatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n   &#125;)\n])</code></pre>\n\n<p>which is exactly the same as above. </p>\n<p>If we use the previously mentioned TypeOf type to get the static type of EventSchema we will get a union of the CreatePost and UpdatePost types. </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Event</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">EventSchema</span>&gt;</code></pre>\n\n<p>The above will be inferred as: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Event</span> = \n    | &#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;CreatePost&quot;</span>, <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span> &#125; &#125;\n    | &#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>, <span class=\"hljs-attr\">data</span>: &#123; title?: <span class=\"hljs-built_in\">string</span>, description?: <span class=\"hljs-built_in\">string</span> &#125; &#125;</code></pre>\n\n<p>which is effectively: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Event</span> = <span class=\"hljs-title class_\">CreatePost</span> | <span class=\"hljs-title class_\">UpdatePost</span></code></pre>\n\n<p>One additional thing that we gain from defining a discriminated union is an exhaustiveness check. So we if we use <code>EventSchema.parse(someData)</code> this will throw a runtime error if someData does not conform to the complete shape of one of the errors.</p>\n<p>We can write our handler as: </p>\n<pre><code class=\"hljs ts\">ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">try</span> &#123; \n        <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title class_\">EventSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data)); <span class=\"hljs-comment\">// Parse will throw for invalid events</span>\n        <span class=\"hljs-comment\">//     ^</span>\n        <span class=\"hljs-comment\">//      `--- CreatePost | UpdatePost</span>\n        <span class=\"hljs-keyword\">switch</span> (parsed.<span class=\"hljs-property\">type</span>) &#123;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;CreatePost&quot;</span>:\n            ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleCreatePost</span>(parsed)) \n            <span class=\"hljs-comment\">//                        ^</span>\n            <span class=\"hljs-comment\">//                        `---- type of parsed is CreatePost in this branch</span>\n            <span class=\"hljs-keyword\">return</span>; \n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>:\n            ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleUpdatePost</span>(parsed))\n            <span class=\"hljs-comment\">//                      ^</span>\n            <span class=\"hljs-comment\">//                       `---- type of parsed is UpdatePost in this branch</span>\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n        <span class=\"hljs-comment\">// Also see https://github.com/colinhacks/zod#error-formatting</span>\n    &#125;\n&#125;)\n</code></pre>\n\n<p>However, it would be also nice to have this exhaustiveness check enforced in our handler at compile time. The way our code is currently written, tomorrow if we add a new type of event in the discriminated union, but forget to add an if-else branch in the above code, it will get silently ignored - Not great. </p>\n<p>We can take advantage of the typescript compiler option <a href=\"https://www.typescriptlang.org/tsconfig#noImplicitReturns\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">noImplicitReturns</a> to enforce this: </p>\n<pre><code class=\"hljs ts\">ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">try</span> &#123; \n        ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-title function_\">handleEvent</span>(<span class=\"hljs-title class_\">EventSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(data)))); <span class=\"hljs-comment\">// Parse will throw for invalid events</span>\n    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n    &#125;\n&#125;);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleEvent</span> = (<span class=\"hljs-params\">event: Event</span>) =&gt; &#123;\n    <span class=\"hljs-keyword\">switch</span> (event.<span class=\"hljs-property\">type</span>) &#123;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;CreatePost&quot;</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">handleCreatePost</span>(event);\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;UpdatePost&quot;</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">handleUpdatePost</span>(event);\n    &#125;\n&#125;</code></pre>\n\n<p>Note that our switch statement does not have a default case. </p>\n<p>So if we update our Event have another variant like: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EventSchema</span> = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(<span class=\"hljs-string\">&quot;type&quot;</span>, [\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;CreatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>\n   &#125;),\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;UpdatePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">PostDetailsSchema</span>.<span class=\"hljs-title function_\">partial</span>()\n   &#125;),\n   z.<span class=\"hljs-title function_\">object</span>(&#123;\n     <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">&quot;DeletePost&quot;</span>),\n     <span class=\"hljs-attr\">data</span>: z.<span class=\"hljs-title function_\">object</span>(&#123; <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>() &#125;)\n   &#125;)\n])</code></pre>\n\n<p>None of the switch-case branches will now match for <code>DeletePost</code> and we will end up with a possible branch of code that returns implicitly. Typescript will now complain about that.</p>\n<p>We could wrap-up the post here - given that we have accomplished all the type-safety features we wanted. However, I am not a huge fan of having to rely on implicit returns (or similar workarounds) for exhaustiveness check. </p>\n<p>In many functional languages, we have support for <a href=\"https://abitofocaml.weebly.com/12-pattern-matching.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">pattern-matching</a> with built in support for exhaustiveness check. Typescript does not have this at the moment but there are userland implementations that emulate pattern matching. One such library is <a href=\"https://github.com/gvergnaud/ts-pattern\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">ts-pattern</a>, which I have found to work very well in practice. </p>\n<p>With ts-pattern we could write our handler as: </p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; match &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-pattern&quot;</span>;\n\n<span class=\"hljs-comment\">// --- </span>\n\n<span class=\"hljs-title function_\">match</span>(event)\n    .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;CreatePost&#x27;</span> &#125;, handleCreatePost)\n    .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;UpdatePost&#x27;</span> &#125;, handleUpdatePost)\n    .<span class=\"hljs-title function_\">exhaustive</span>()   <span class=\"hljs-comment\">// &lt;--- will be a type error if Event type has any other union members</span></code></pre>\n\n<p>Not only is this more succinct for this use case, ts-pattern becomes more useful when we have more complex scenario like combining multiple predicates or performing checks based on multiple properties. Take a look at some of their examples in the <a href=\"https://github.com/gvergnaud/ts-pattern#readme\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">docs</a>.</p>\n<p>Also, unlike our switch-case or if-else examples above, the entire match invocation is a single expression so we could use the return value of our handler without needing temporary variables.</p>\n<pre><code class=\"hljs ts\">ws.<span class=\"hljs-title function_\">send</span>(\n    <span class=\"hljs-title function_\">match</span>(event)\n        .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;CreatePost&#x27;</span> &#125;, handleCreatePost)\n        .<span class=\"hljs-title function_\">with</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;UpdatePost&#x27;</span> &#125;, handleUpdatePost)\n        .<span class=\"hljs-title function_\">exhaustive</span>()\n)</code></pre>\n\n<p>Cool, eh ?</p>\n",
            "tags": [
                "typescript",
                "zod",
                "ts-match"
            ]
        },
        {
            "id": "https://lorefnon.me/2022/06/18/type-safe-jsonb-with-ts-sql-query/",
            "url": "https://lorefnon.me/2022/06/18/type-safe-jsonb-with-ts-sql-query/",
            "title": "Making jsonb access type-safe with a zod adapter in ts-sql-query",
            "date_published": "2022-06-18T00:00:00.000Z",
            "content_html": "<p><a href=\"https://ts-sql-query.readthedocs.io/en/stable\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">ts-sql-query</a> is a nice typescript library for typesafe database access. It goes to great lengths to ensure that if code compiles without type errors then all generated SQL is correct. Of course there are escape hatches for advanced scenarios, but having type-safety for the 90% most common usages is a huge productivity boost.</p>\n<p>Modern databases like postgres have built in json support, enabling us to store semi-structured data in a database column. While this does go against norms of traditional normalization, in practice it is immensely convenient for cases where shaping the data into tabular format is either very time consuming or simply not feasible because the entire structure of data is not known ahead of time or changes frequently.</p>\n<p>However, to be able to effectively process this data in application layer, it is often beneficial to have an application-side schema to validate this json data even if this schema is not 100% known ahead of time, evolves alongside our understanding of data or not 100% strict.</p>\n<p>In typescript, we have a multitude of options for schema validation like <a href=\"https://zod.dev/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">zod</a>, <a href=\"https://github.com/gcanti/io-ts\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">io-ts</a>, <a href=\"https://joi.dev/api/?v=17.6.0\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">joi</a> etc. In this post we primarily focus on zod because IMHO it strikes a very good balance between a user friendly API, available features and being able to extract static types from schema definitions.</p>\n<p>Whiel ts-sql-query does not have json support built-in, it supports custom types through <a href=\"https://ts-sql-query.readthedocs.io/en/stable/supported-operations/#type-adpaters\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">TypeAdapter</a>. So for our jsonb columns we can write a TypeAdapter that utilizes zod to enforce that the data coming from and going to the database conforms to our expectations.</p>\n<p>Let&#39;s say we have a zod type ChapterMedatadata:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">array</span>(),\n&#125;);\n\n<span class=\"hljs-comment\">// Extract static type</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ChapterMetadata</span> = z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>&gt;;</code></pre>\n\n<p>Following would be a type adapter that validates the incoming and outgoing json through this type:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">DefaultTypeAdapter</span>, <span class=\"hljs-title class_\">TypeAdapter</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-sql-query/TypeAdapter&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>: <span class=\"hljs-title class_\">TypeAdapter</span> = &#123;\n    <span class=\"hljs-title function_\">transformValueFromDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-comment\">// Our database adapter (postgres) is aware of jsonb and has already</span>\n            <span class=\"hljs-comment\">// parsed the JSON. So we don&#x27;t need JSON.parse. However if the dabase</span>\n            <span class=\"hljs-comment\">// didn&#x27;t have first class support for json type and</span>\n            <span class=\"hljs-comment\">// we were storing the JSON in a text field we would need to do a JSON.parse first</span>\n            <span class=\"hljs-comment\">// before calling ChapterMetadataSchema.parse</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n\n        <span class=\"hljs-comment\">// If type is not jsonb then gracefully fallback to the next adapter</span>\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueFromDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n\n    <span class=\"hljs-title function_\">transformValueToDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-comment\">// This is strictly not necessary because TS will ensure</span>\n            <span class=\"hljs-comment\">// that atleast the static type is enforced.</span>\n            <span class=\"hljs-comment\">//</span>\n            <span class=\"hljs-comment\">// However it offers aditional safety if we have some refinements</span>\n            <span class=\"hljs-comment\">// or if there is possibility of values with any type creeping in.</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n\n        <span class=\"hljs-comment\">// If type is not jsonb gracefully fallback to the next adapter</span>\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueToDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n&#125;;</code></pre>\n\n<p>Once we have the adapter in place, we can use this in our table mapping:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Table</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ts-sql-query/Table&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChaptersTable</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Table</span>&lt;<span class=\"hljs-title class_\">DBConnection</span>, <span class=\"hljs-string\">&quot;ChaptersTable&quot;</span>&gt; &#123;\n    id = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">autogeneratedPrimaryKey</span>(<span class=\"hljs-string\">&quot;id&quot;</span>, <span class=\"hljs-string\">&quot;int&quot;</span>);\n    metadata = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">optionalColumn</span>&lt;<span class=\"hljs-title class_\">ChapterMetadata</span>&gt;(\n        <span class=\"hljs-string\">&quot;metadata&quot;</span>,\n        <span class=\"hljs-string\">&quot;custom&quot;</span>,\n        <span class=\"hljs-string\">&quot;jsonb&quot;</span>,\n        <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>\n    );\n\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;\n        <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-string\">&quot;chapters&quot;</span>);\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> tChapters = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChaptersTable</span>();</code></pre>\n\n<p>So now whenever we try to retrieve the data from database, the value for metadata column will be validated against our schema.</p>\n<p>And because we have passed the ChapterMetadata static type as a type parameter to the column, for operations performed in typescript codebase, we get static type safety as well:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-title function_\">getConnection</span>()\n    .<span class=\"hljs-title function_\">insertInto</span>(tChapters)\n    .<span class=\"hljs-title function_\">set</span>(&#123; <span class=\"hljs-attr\">metadata</span>: &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Test&quot;</span>, <span class=\"hljs-attr\">topic</span>: <span class=\"hljs-string\">&quot;test&quot;</span> &#125; &#125;); <span class=\"hljs-comment\">// &lt;-- Static type error</span></code></pre>\n\n<p>Note that whenever we are performing type validation of data coming from a long term storage, we need to be cautious with schema evolution.</p>\n<p>Tomorrow if we update the type and add backward incompatible changes (eg. new mandatory fields), then the rows containing past data can become inaccessible.</p>\n<p>So it is better to ensure that any schema change is additive, and new fields added are optional. It is also useful to perform two step transitions where in the transition duration the schema is compatible with both previous and new shape of data (at the cost of being more relaxed than is necessary).</p>\n<p>Lastly, the above type adapter assumes that the shape of data as stored in database matches the shape of the data that the application deals with.</p>\n<p>It can sometimes be desirable to store the data in a different format than what the application deals. This could be either to facilitate ease of indexing or compaction of storage on the db side, or to use more complex data structures than json-compatible objects and arrays on the application side.</p>\n<p>While zod does not support codecs like some other libraries like io-ts, it is possible to use two different (mutually compatible) types in transformValueToDB and transformValueFromDB to convert between the two representations.</p>\n<p>A simple example of two such types can be:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> z <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z\n        .<span class=\"hljs-title function_\">string</span>()\n        .<span class=\"hljs-title function_\">array</span>()\n        .<span class=\"hljs-title function_\">transform</span>(\n            <span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n                <span class=\"hljs-comment\">// Convert the JSON array to a Set</span>\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(it)\n        ),\n    <span class=\"hljs-attr\">relevanceScores</span>: z.<span class=\"hljs-title function_\">record</span>(z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">transform</span>(\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n            <span class=\"hljs-comment\">// Convert the JSON object to a Map</span>\n            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(it))\n    ),\n&#125;);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span> = z.<span class=\"hljs-title function_\">object</span>(&#123;\n    <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">topics</span>: z.<span class=\"hljs-title function_\">set</span>(z.<span class=\"hljs-title function_\">string</span>()).<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n        <span class=\"hljs-comment\">// Convert set to array</span>\n        [...it]\n    ),\n    <span class=\"hljs-attr\">relevanceScores</span>: z.<span class=\"hljs-title function_\">map</span>(z.<span class=\"hljs-title function_\">string</span>(), z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">it</span>) =&gt;</span>\n        <span class=\"hljs-comment\">// Convert Map to object</span>\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(it.<span class=\"hljs-title function_\">entries</span>())\n    ),\n&#125;);</code></pre>\n\n<p>Now we can change our adapter to use these two separate types:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ChapterMetadataAdapter</span>: <span class=\"hljs-title class_\">TypeAdapter</span> = &#123;\n    <span class=\"hljs-title function_\">transformValueFromDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueFromDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n\n    <span class=\"hljs-title function_\">transformValueToDB</span>(\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span>,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">string</span>,\n        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">DefaultTypeAdapter</span>\n    ): <span class=\"hljs-built_in\">unknown</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">&quot;jsonb&quot;</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span>.<span class=\"hljs-title function_\">parse</span>(value);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">transformValueToDB</span>(value, <span class=\"hljs-keyword\">type</span>);\n    &#125;,\n&#125;;</code></pre>\n\n<p>We need to make sure that these two types are always mutually compatible ie. for any valid values</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>.<span class=\"hljs-title function_\">parse</span>(value));</code></pre>\n\n<p>succeeds, and vice versa.</p>\n<p>We can use unit tests to ensure that, and we can also add witness types to validate the compatibility of corresponding static types.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Type that enforces that U is assignable to T</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ExtendsWitness</span>&lt;U <span class=\"hljs-keyword\">extends</span> T, T&gt; = U;\n\n<span class=\"hljs-comment\">// If the Input type of ChapterMetadataAppToDBSchema is not compatbile with</span>\n<span class=\"hljs-comment\">// output type of ChapterMetadataDBToAppSchema following witness will have a type error</span>\n<span class=\"hljs-keyword\">type</span> _ChapterMetadataWitness1 = <span class=\"hljs-title class_\">ExtendsWitness</span>&lt;\n    z.<span class=\"hljs-property\">TypeOf</span>&lt;<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataDBToAppSchema</span>&gt;,\n    <span class=\"hljs-comment\">// Extract input type from ChapterMetadataAppToDBSchema</span>\n    <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">ChapterMetadataAppToDBSchema</span> <span class=\"hljs-keyword\">extends</span> z.<span class=\"hljs-property\">ZodType</span>&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>, infer <span class=\"hljs-title class_\">TIn</span>&gt;\n        ? <span class=\"hljs-title class_\">TIn</span>\n        : <span class=\"hljs-built_in\">never</span>\n&gt;;</code></pre>\n\n<p>and similarly the other way round.</p>\n",
            "tags": [
                "typescript",
                "zod",
                "ts-sql-query"
            ]
        }
    ]
}