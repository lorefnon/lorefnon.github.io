{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought â€¢ All posts by \"design patterns\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2015/01/03/leveraging-strategy-pattern-in-rails.html",
            "url": "https://lorefnon.me/2015/01/03/leveraging-strategy-pattern-in-rails.html",
            "title": "Leveraging the strategy pattern in Rails - I",
            "date_published": "2015-01-03T00:00:00.000Z",
            "content_html": "<h1 id=\"To-begin-with-what-is-strategy-pattern\"><a href=\"#To-begin-with-what-is-strategy-pattern\" class=\"headerlink\" title=\"To begin with, what is strategy pattern ?\"></a>To begin with, what is strategy pattern ?</h1><p>Quoting from <a href=\"http://en.wikipedia.org/wiki/Strategy_pattern\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Wikipedia</a>,</p>\n<blockquote>\n<p>the strategy pattern (also known as the policy pattern) is a software design\npattern that enables an algorithm&#39;s behavior to be selected at runtime.</p>\n</blockquote>\n<h1 id=\"So-how-does-this-help-us\"><a href=\"#So-how-does-this-help-us\" class=\"headerlink\" title=\"So how does this help us ?\"></a>So how does this help us ?</h1><p>Strategy pattern just helps us escape the soup of complex nested conditionals\nand model behavior selection in an object oriented fashion. To understand why this is\nrequired let us explore a fictional example:</p>\n<h1 id=\"An-adventure\"><a href=\"#An-adventure\" class=\"headerlink\" title=\"An adventure\"></a>An adventure</h1><p>Suppose that we are developing a social network for book lovers. To encourage users\nto read more we decide to show a recommendations panel which highlights books that\nare trending in the community.</p>\n<p>Our (over-simplified) implementation might be something like:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n\n  has_many <span class=\"hljs-symbol\">:recommendations</span>\n  has_many <span class=\"hljs-symbol\">:tags</span>\n\n  scope <span class=\"hljs-symbol\">:popular</span>, -&gt; &#123;  where <span class=\"hljs-string\">&#x27;recommendations_count &gt; 100&#x27;</span> &#125;\n\n  <span class=\"hljs-comment\"># Return a random subset of recommended books</span>\n  <span class=\"hljs-comment\">#</span>\n  <span class=\"hljs-comment\"># Yes, this approach is sub-optimal for large number of popular books. Better</span>\n  <span class=\"hljs-comment\"># approaches are outlined here:</span>\n  <span class=\"hljs-comment\"># http://stackoverflow.com/questions/4329396/mysql-select-10-random-rows-from-600k-rows-fast</span>\n  <span class=\"hljs-comment\">#</span>\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">self</span>.recommended\n    popular.order(<span class=\"hljs-string\">&#x27;RAND()&#x27;</span>).limit(<span class=\"hljs-number\">5</span>)\n  <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Recommendation</span>\n  belongs_to <span class=\"hljs-symbol\">:user</span>, <span class=\"hljs-symbol\">counter_cache:</span> <span class=\"hljs-literal\">true</span>\n  belongs_to <span class=\"hljs-symbol\">:book</span>, <span class=\"hljs-symbol\">counter_cache:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>In home&#x2F;index.html.erb</p>\n<pre><code class=\"hljs erb\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&#x27;recommended-book-list&#x27;</span>&gt;</span></span>\n<span class=\"language-xml\">  &lt;%</span><span class=\"language-ruby\"> Book.recommended.each <span class=\"hljs-keyword\">do</span> </span><span class=\"language-xml\">%&gt;</span>\n<span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span> &lt;%=</span><span class=\"language-ruby\"> book.title </span><span class=\"language-xml\">%&gt; <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n<span class=\"language-xml\">  &lt;%</span><span class=\"language-ruby\"> <span class=\"hljs-keyword\">end</span> </span><span class=\"language-xml\">%&gt;</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span></code></pre>\n\n<p>So far so good, however we realize that for users who have been using our service\nfor a while, it makes more sense to show recommendations based on their intersts. So we do a\nshotgun surgery and modify our code to the following:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n  ...\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">self</span>.recommended_for user\n    <span class=\"hljs-keyword\">if</span> user.blank? |<span class=\"hljs-params\"></span>| (user.recommendations_count &lt; <span class=\"hljs-number\">5</span>)\n      popular\n    <span class=\"hljs-keyword\">else</span>\n      not_recommended_by(user).where(<span class=\"hljs-symbol\">tags:</span> user.recommended_tags)\n    <span class=\"hljs-keyword\">end</span>.order(<span class=\"hljs-string\">&#x27;RAND()&#x27;</span>).limit(<span class=\"hljs-number\">5</span>)\n  <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n  ...\n  has_many <span class=\"hljs-symbol\">:recommendations</span>\n  has_many <span class=\"hljs-symbol\">:recommended_books</span>,\n    <span class=\"hljs-symbol\">through:</span> <span class=\"hljs-symbol\">:recommendations</span>,\n    <span class=\"hljs-symbol\">source:</span> <span class=\"hljs-symbol\">:book</span>\n  has_many <span class=\"hljs-symbol\">:recommended_tags</span>,\n    <span class=\"hljs-symbol\">through:</span> <span class=\"hljs-symbol\">:recommended_books</span>,\n    <span class=\"hljs-symbol\">source:</span> <span class=\"hljs-symbol\">:tags</span>\n\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n  ...\n  scope <span class=\"hljs-symbol\">:not_recommended_by</span>, -&gt; (user) <span class=\"hljs-keyword\">do</span>\n    joins(<span class=\"hljs-symbol\">:recommendations</span>)\n      .where(<span class=\"hljs-string\">&#x27;recommendations.user_id != ?&#x27;</span>, user.id)\n  <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>And our template becomes something like:</p>\n<pre><code class=\"hljs erb\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&#x27;recommended-book-list&#x27;</span>&gt;</span></span>\n<span class=\"language-xml\">  &lt;%</span><span class=\"language-ruby\"> Book.recommended_for(current_user).each <span class=\"hljs-keyword\">do</span> </span><span class=\"language-xml\">%&gt;</span>\n<span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span> &lt;%=</span><span class=\"language-ruby\"> book.title </span><span class=\"language-xml\">%&gt; <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n<span class=\"language-xml\">  &lt;%</span><span class=\"language-ruby\"> <span class=\"hljs-keyword\">end</span> </span><span class=\"language-xml\">%&gt;</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span></code></pre>\n\n<p>We see that at this point our <code>recommended_for</code> method is burdened with multiple\nresponsibilities - the decision for the approach to be used as well as the logic\nfor multiple approaches all reside in the same method, which is not very ideal.</p>\n<p>Let us push this further. Say, after a couple of months our social networks gains\na lot of traction and we strike a very profitable deal with a major publishing\nfirm &#39;Jackass Kangaroo Publications&#39; and as a part of the deal we need to ensure\nthat the recommended books include only those which have been published by this\npublication.</p>\n<p>No problem, we just need add a few lines of code:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n  ...\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">self</span>.recommended_for user\n    query = Book\n\n    <span class=\"hljs-comment\"># Comment this out when deal with Jackass Kangaroo Publication is over.</span>\n    query = query.where(<span class=\"hljs-symbol\">publisher:</span> Publisher.where(<span class=\"hljs-symbol\">name:</span> <span class=\"hljs-string\">&#x27;Jackass Kangaroo Publication&#x27;</span>).first)\n\n    <span class=\"hljs-keyword\">if</span> user.blank? |<span class=\"hljs-params\"></span>| (user.recommendations_count &lt; <span class=\"hljs-number\">5</span>)\n      query.popular\n    <span class=\"hljs-keyword\">else</span>\n      query.not_recommended_by(user).where(<span class=\"hljs-symbol\">tags:</span> user.recommended_tags)\n    <span class=\"hljs-keyword\">end</span>.order(<span class=\"hljs-string\">&#x27;RAND()&#x27;</span>).limit(<span class=\"hljs-number\">5</span>)\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>No words are needed to describe the ugliness of the code above. Our eyes bleed but we\nchoose to look away and carry on with our buisness.</p>\n<p>Of course, the journey of our social network is not all rosy. We get hit by a\nlawsuit making our deal with <code>Jackass Kangaroo Publications</code> illegal in a specific country.\nBut why bother backing off from this insanity when all problems can be resolved\nby adding just another condition:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n  ...\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">self</span>.recommended_for user\n    query = Book\n\n    <span class=\"hljs-comment\"># Comment this out when deal with Jackass Kangaroo Publication is over.</span>\n    <span class=\"hljs-keyword\">unless</span> user.located_in? <span class=\"hljs-variable constant_\">DISPUTED_DEMOGRAPHY</span>\n      query = query.where(<span class=\"hljs-symbol\">publisher:</span> Publisher.where(<span class=\"hljs-symbol\">name:</span> <span class=\"hljs-string\">&#x27;Jackass Kangaroo Publication&#x27;</span>).first)\n    <span class=\"hljs-keyword\">end</span>\n\n    ...\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<h1 id=\"A-downhill-slope\"><a href=\"#A-downhill-slope\" class=\"headerlink\" title=\"A downhill slope\"></a>A downhill slope</h1><p>So requirements keep stacking up and we keep adding conditions. Fast forward a few years, and\na sincere programmer who is new to the project, unfamiliar with our rocky history and now is responsible\nfor maintenance of the project is staring\nblankly at the entangled mess of conditional statements. Of course the crutial details of the deal\nand the subsequent lawsuits are now lost in sands of time, and none of the present team members\nhave any idea what is going on.</p>\n<h1 id=\"Retrospection\"><a href=\"#Retrospection\" class=\"headerlink\" title=\"Retrospection\"></a>Retrospection</h1><p>The question now is, what could be done to avoid a situation like this ? As you might have guessed\nat this point, burdening the Book class with responsibility to determine various aspects of\napplication that affect our recommendation policy as well as the complete implementation of all these policies\nis cumbersome. What we can do is that we can refactor out the specific strategies into dedicated\nclasses that encapsulate the actual implementation details. This is exactly what the strategy pattern\nencourages us to embrace.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">module</span> Strategies\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RecommendationGeneration</span> &lt; <span class=\"hljs-title class_ inherited__\">Struct</span>.new(user, scoped_collection)\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scoped_collection</span>\n      <span class=\"hljs-variable language_\">super</span> |<span class=\"hljs-params\"></span>| Book\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">applicable?</span>\n      <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">execute</span>\n    <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n<br>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">module</span> Strategies\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultRecommendationGeneration</span> &lt; <span class=\"hljs-title class_ inherited__\">RecommendationGeneration</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">applicable?</span>\n          <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">end</span>\n\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scoped_collection</span>\n          <span class=\"hljs-variable language_\">super</span> |<span class=\"hljs-params\"></span>| popular\n        <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">execute</span>\n          scoped_collection.order(<span class=\"hljs-string\">&#x27;RAND()&#x27;</span>).limit(<span class=\"hljs-number\">5</span>)\n    <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n<br>\n<pre><code class=\"hljs ruby\">\n<span class=\"hljs-keyword\">module</span> Strategies\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserAdaptedRecommendationGeneration</span> &lt; <span class=\"hljs-title class_ inherited__\">RecommendationGeneration</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">applicable?</span>\n      user.present?\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scoped_collection</span>\n      <span class=\"hljs-keyword\">if</span> user.present?\n        not_recommended_by(user).where(<span class=\"hljs-symbol\">tags:</span> user.recommended_tags)\n      <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-variable language_\">super</span>\n          <span class=\"hljs-keyword\">end</span>\n        <span class=\"hljs-keyword\">end</span>\n\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">execute</span>\n          Strategies::DefaultRecommendation\n            .new(user, scoped_collection)\n                .execute\n        <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n<br>\n<pre><code class=\"hljs ruby\">\n<span class=\"hljs-keyword\">module</span> Strategies\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PartnershipAdaptedRecommendationGeneration</span> &lt; <span class=\"hljs-title class_ inherited__\">RecommendationGeneration</span>\n\n    <span class=\"hljs-comment\"># It is better to model buisness constraints in the persistance layer</span>\n        <span class=\"hljs-comment\"># rather than relying on implicit assumptions.</span>\n        <span class=\"hljs-comment\">#</span>\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">applicable?</span>\n          ! partner_publisher.blank?\n        <span class=\"hljs-keyword\">end</span>\n\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">partner_publisher</span>\n          Partnership\n            .legal_in(user.demography)\n        .having_recommendation_priviledge\n                .active\n                .first\n                .publisher\n        <span class=\"hljs-keyword\">end</span>\n\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scoped_collection</span>\n          Book.where(<span class=\"hljs-symbol\">publisher:</span> partner_publisher)\n        <span class=\"hljs-keyword\">end</span>\n\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">execute</span>\n          Strategies::UserAdaptedRecommendationGeneration\n                .new(user, scoped_collection)\n                .execute\n        <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n\n<p>Now our <code>recommended_for</code> method just has to decide which is the applicable strategy and execute\nit:</p>\n<pre><code class=\"hljs ruby\">\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span> &lt; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Base</span>\n  ...\n\n  <span class=\"hljs-variable constant_\">RECOMMENDATION_STRATEGIES</span> = [\n    PartnershipAdaptedRecommendationGeneration\n        UserAdaptedRecommendationGeneration\n        DefaultRecommendationGeneration\n  ]\n\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">self</span>.recommended_for user\n    <span class=\"hljs-variable constant_\">RECOMMENDATION_STRATEGIES</span>.each <span class=\"hljs-keyword\">do</span> |<span class=\"hljs-params\">strategy_class</span>|\n          strategy = strategy_class.new(user)\n          <span class=\"hljs-keyword\">if</span> strategy.applicable?\n            strategy.execute\n                <span class=\"hljs-keyword\">break</span>\n          <span class=\"hljs-keyword\">end</span>\n        <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n\n<p>This is signficantly better than our prior approach and aligns well with the tenets of\n<a href=\"http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">SOLID</a> principles. Apart from\nexplaining the use of strategy pattern it also illustrates how strategies can reuse existing\nstrategies by means of composition thus keeping our code DRY.</p>\n<p>So we see that, the strategy pattern is especially helpful when it comes to applications where\nrequirements are rapidly changing all the time. Since the core logic is encapsulated\ninto interchangeable concrete implementations, strategy implementations can be\nintroduced or switched with relative ease at a later phase.</p>\n<p>While this post focussed on use of strategy pattern to simply complex logic in model layer, in\nsubsequent posts we will cover how this pattern can simplify our implementations in controller\nand view layers as well.</p>\n<p>This concludes the post. Please feel free to let me know about your suggestions for improvements, or\nmistakes that I might have made in the post above.</p>\n",
            "tags": [
                "Ruby",
                "Rails",
                "Design Patterns"
            ]
        }
    ]
}