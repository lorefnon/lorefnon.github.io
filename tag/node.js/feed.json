{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought • All posts by \"node.js\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2012/12/12/sharing-jade-templates-between-nodejs-server-and-client.html",
            "url": "https://lorefnon.me/2012/12/12/sharing-jade-templates-between-nodejs-server-and-client.html",
            "title": "Sharing Jade templates between Node.js server and client",
            "date_published": "2012-12-12T00:00:00.000Z",
            "content_html": "<p>Although there are several templating options available for the client eg. <a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Handlebars</a>, <a href=\"http://mustache.github.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Mustache</a>, <a href=\"http://beebole.com/pure/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Pure</a> etc. nevertheless, <a href=\"http://jade-lang.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Jade</a> is attractive in its own right.  Its succinct syntax is cleaner even than <a href=\"http://haml.info/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Haml</a>, which is arguably the predecessor and inspiration-source of all the minimalist whitespace sensitive templating systems. Using Node.js on the server offers an interesting opportunity to reuse the same servers on the server as well as client. This has been made particulary easy by the <a href=\"https://github.com/search?q=jade&ref=commandbar\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">numerous community contributions</a> by Jade enthusiasts which I will attempt to highlight in this post.</p>\n<p>When using Jade on the client the most naive approach would be  fetching our typical .jade file via ajax and then parsing the file and then  manipulating the structure and  interpolating the various variables. However,  we can pre-process the jade file beforehand thereby eliminating the heavyweight parsing step in the client. The end result of the pre-processing is a function which takes in the variables needed to render the template and then outputs the resultant HTML string which can be injected into the DOM.</p>\n<p>Preprocessing also takes care of <a href=\"https://github.com/visionmedia/jade#template-inheritance\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">template-inheritance</a> and <a href=\"https://github.com/visionmedia/jade#includes\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">template-inclusion</a> seamlessly which are difficult to implement in pure clienside parsing without an added layer of complexity and overhead of multiple ajax calls.</p>\n<p>Client-side rendering is made possible by a Jade feature called jade-runtime. On supplying a -c flag to jade, it generates the compiled javascript template which can be used along with the <a href=\"https://github.com/visionmedia/jade/blob/master/runtime.js\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">runtime.js</a> .</p>\n<p><a href=\"https://github.com/jgallen23/clientjade\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Clientjade</a> takes the process to next level of simplicity.  It is simple npm module which provides you with a command line utility to compile several jade templates into a single compiled javascript file. Compilation is as simple as:</p>\n<pre><code>clientjade test1.jade test2.jade &gt; templates.js\n</code></pre>\n<p>Once templates.js has been included in the page,  individual templates can be accessed using their filenames.</p>\n<pre><code>jade.render($(&#39;#target&#39;), &#39;test1&#39;, &#123; name: &#39;Bob&#39; &#125;);\n</code></pre>\n<p>First argument is the DOM node where the template is to be rendered, second is a reference to the template and last is the data required to render the template.</p>\n<p>While this entire procedure is very simple, inclusion of multiple compiled templates in an HTML page leads to headaches.  Reason is that every individual compiled file assigns an empty hash to internal object containing references to templates. While in casual usage this is usually not a problem because you can always compile all the templates you need into a single javascript file, this can become troublesome if you are loading templates on-the-fly, as per requirements. The most common scenario is the case when an AMD loader eg. RequireJS is being used to manage dependencies.</p>\n<p>Fortunately there is a sister project <a href=\"https://github.com/mysociety/node-jade-amd\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">node-jade-amd</a> which focusses on exactly this usage scenario. As you might expect, after installing the <a href=\"https://github.com/mysociety/node-jade-amd\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">jade-amd</a> npm module you have a handy command line utility using which is as simple as :</p>\n<pre><code>jade-amd --from &lt;source-folder&gt; --to &lt;destination-folder&gt;\n</code></pre>\n<p>The compiled templates have a dependency on jadeRuntime amd module which can be obtained by :</p>\n<pre><code>jade-amd --runtime &gt; jadeRuntime.js\n</code></pre>\n<p>Then the compiled template can be used just like you would use any other amd module :</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">require</span>([ <span class=\"hljs-string\">&#x27;templates/person&#x27;</span> ],            <span class=\"hljs-comment\">// Compiled template AMD modules</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">personTemplate</span>) </span>&#123;\n        <span class=\"hljs-keyword\">var</span> rendered_content = personTemplate(&#123;\n              <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Joe Bloggs&#x27;</span>                <span class=\"hljs-comment\">// Data to be used in the template</span>\n         &#125;);\n    &#125;\n);</code></pre>\n<p>Note that explitly requiring the runtime is not necessary because it is implicitly required by the compiled templates.</p>\n<p>If repeated manual recompilation feels like a headache, and you don’t already have a file watcher setup there is a connect middleware <a href=\"https://github.com/storify/jade-browser\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">jade-browser</a> which exposes jade templates to the web browser and also provides a few additional features like express-like render function with partial handling. If you already using <a href=\"http://gruntjs.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">grunt</a>, you can checkout the plugin <a href=\"https://github.com/phated/grunt-jade\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">grunt-jade</a> .</p>\n<p>So jade is an immensely popular templating solution among Node.js developers and the benefit of this is that there are numerous compilation options available to fit into your development toolchain.  I hope this quick detour around jade was helpful.  There are multiple other similar projects aiming to solve similar scenarios.  The ones aforementioned, were a few that I recently used. Please feel free to express any opinions or criticisms. If there is a project with related objectives which is particularly noteworthy,  feel free to add a link.</p>\n",
            "tags": [
                "Javascript",
                "Jade",
                "Node.js"
            ]
        }
    ]
}