{
    "version": "https://jsonfeed.org/version/1",
    "title": "Icicles of Thought • All posts by \"knockoutjs\" tag",
    "description": "",
    "home_page_url": "https://lorefnon.me",
    "items": [
        {
            "id": "https://lorefnon.me/2015/08/24/smarter-knockout-applications-with-es-next.html",
            "url": "https://lorefnon.me/2015/08/24/smarter-knockout-applications-with-es-next.html",
            "title": "Smarter knockout applications with ES6/7",
            "date_published": "2015-08-24T00:00:00.000Z",
            "content_html": "<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>This post is an outline of ES6&#x2F;7 features that we can leverage today in our <a href=\"http://knockoutjs.com/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Knockout</a> based applications to make them more maintainable.</p>\n<p>Thanks to powerful and reliable transpilers like <a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Babel</a> we don&#39;t have to wait for mass adoption across browser vendors, to try out features from next generation javascript. While this post is essentially an overview written in a specific context, ie. Knockout applications, I encourage readers to refer to excellent online resources like <a href=\"https://leanpub.com/javascriptallongesix\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Javascript Allonge</a> for a broader coverage.</p>\n<h2 id=\"View-Models-as-ES-6-classes\"><a href=\"#View-Models-as-ES-6-classes\" class=\"headerlink\" title=\"View Models as ES 6 classes:\"></a>View Models as ES 6 classes:</h2><p>View models are typically defined as javascript constructor functions. ES6 classes offer a bit of syntax sugar over prototypal inheritance and the outcome might appeal to people coming other object oriented languages.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeViewModel</span> &#123;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n  &#125;\n&#125;\n\nko.<span class=\"hljs-property\">components</span>.<span class=\"hljs-title function_\">register</span>(&#123;\n  <span class=\"hljs-attr\">viewModel</span>: <span class=\"hljs-title class_\">SomeViewModel</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;&lt;div data-bind=&quot;text: firstName&quot;&gt;&lt;/div&gt;&#x27;</span>\n&#125;)</code></pre>\n\n<h2 id=\"Arrow-functions-in-computed-properties\"><a href=\"#Arrow-functions-in-computed-properties\" class=\"headerlink\" title=\"Arrow functions in computed properties:\"></a>Arrow functions in computed properties:</h2><p>In computed properties it is more often than not desirable that the context of function be the same as that of the outer function. Patterns like <code>var self = this</code> have been adopted widely for situations like this.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SomeViewModel</span>(<span class=\"hljs-params\"></span>) &#123;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-variable language_\">this</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fullName</span> = ko.<span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;\n    <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-title function_\">firstName</span>() + <span class=\"hljs-string\">&#x27; &#x27;</span> + self.<span class=\"hljs-title function_\">lastName</span>();\n  &#125;);\n&#125;</code></pre>\n\n<p>Arrow functions simplify this use case by providing special syntax for functions which, as MDN <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">explains</a> it, capture the this value of the enclosing context</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeViewModel</span> &#123;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fullName</span> = ko.<span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">firstName</span>() + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">lastName</span>();\n    &#125;);\n  &#125;\n&#125;</code></pre>\n\n<p>Or for smaller functions we can reduce the verbosity even further:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeViewModel</span> &#123;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span> = ko.<span class=\"hljs-title function_\">observable</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fullName</span> = ko.<span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">firstName</span>() + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">lastName</span>());\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"Imports-for-code-organization\"><a href=\"#Imports-for-code-organization\" class=\"headerlink\" title=\"Imports for code organization:\"></a>Imports for code organization:</h2><p>JS imports are the new standard approach to deal with modularization in JS code, and I can only anticipate <a href=\"https://angular.io/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">more</a> and <a href=\"http://aurelia.io/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">more</a> libraries moving to them from older patterns like <a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">AMD</a> or <a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">CommonJS</a>. Babel can transpile imports to require invocations that follow AMD&#x2F;CommonJS syntax so you can move to newer syntax progressively and continue using your existing loaders&#x2F;bundlers. My personal recommendation for bundler is <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">webpack</a> which offers interesting features like <a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Code splitting</a> out of the box.</p>\n<h2 id=\"Template-strings\"><a href=\"#Template-strings\" class=\"headerlink\" title=\"Template strings\"></a>Template strings</h2><p>Template strings make it easy to define small multi-line templates along side view models.</p>\n<pre><code class=\"hljs plaintext\">ko.components.register(&#123;\n  viewModel: SomeViewModel,\n  template:\n    `&lt;div&gt;\n      &lt;h1&gt; Hello friend, nice to meet you &lt;/h1&gt;\n      &lt;div&gt;\n        Dear &lt;span data-bind=&quot;text: firstName()&quot;&gt;&lt;/span&gt; It is nice to meet you.\n      &lt;/div&gt;\n    &lt;/div&gt;`\n&#125;);</code></pre>\n\n<p>Although for larger templates I recommend using something like <a href=\"https://github.com/webpack/raw-loader\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">webpack-raw-loader</a> so you can write:</p>\n<pre><code class=\"hljs javascript\">ko.<span class=\"hljs-property\">components</span>.<span class=\"hljs-title function_\">register</span>(&#123;\n  <span class=\"hljs-attr\">viewModel</span>: <span class=\"hljs-title class_\">SomeViewModel</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./some_view_model.html&#x27;</span>)\n&#125;);</code></pre>\n\n<p>However larger templates more often than not indicate need for fine-grained modularization, so the above recommendation should be taken with a pinch of salt.</p>\n<h2 id=\"ES7-Decorators-for-Component-registration\"><a href=\"#ES7-Decorators-for-Component-registration\" class=\"headerlink\" title=\"ES7 Decorators for Component registration:\"></a>ES7 Decorators for Component registration:</h2><p>If you have been keeping up with advancements with Angular 2.0, you may have noticed the use of annotations for component registration. Here is an example from their <a href=\"https://angular.io/docs/js/latest/quickstart.html\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">quick start tutorial</a> showing how annotations go hand in hand with the new class syntax:</p>\n<pre><code class=\"hljs plaintext\">// Annotation section\n@Component(&#123;\n  selector: &#x27;my-app&#x27;\n&#125;)\n@View(&#123;\n  template: &#x27;&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;&#x27;\n&#125;)\n// Component controller\nclass MyAppComponent &#123;\n  name: string;\n  constructor() &#123;\n    this.name = &#x27;Alice&#x27;;\n  &#125;\n&#125;</code></pre>\n\n<p>While I refer to <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">this excellent writeup</a> by <a href=\"https://twitter.com/wycats\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Yehuda Katz</a> on javascript decorators for an indepth overview, the following snippet is a quick overview as to how we can leverage javascript decorators to handle component registration in knockout:</p>\n<pre><code class=\"hljs plaintext\">function Component(params) &#123;\n  return function(viewModel) &#123;\n    ko.components.register(params.name, &#123;\n      viewModel: viewModel,\n      template: params.template\n    &#125;)\n  &#125;\n&#125;</code></pre>\n\n<p>Once our <code>Component</code> decorator has been defined we can simply use it like this:</p>\n<pre><code class=\"hljs plaintext\">@Component(&#123;\n  name: &#x27;my-app-component&#x27;,\n  template:\n    `&lt;div&gt;\n      ...\n    &lt;/div&gt;`\n&#125;)\nclass MyAppViewModel &#123;\n  constructor() &#123;\n    ...\n  &#125;\n&#125;</code></pre>\n\n<p>You may be tempted to use the <code>target.name</code> to enforce some module naming conventions, but before you tread that way please be aware of lack of IE support for <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Function#name</a>.</p>\n<p>This concludes this overview for now, though there is a lot to be explored in next generation javascript beyond this basic introduction. As always, I welcome any suggestions or requests for improvement in the comments section below.</p>\n",
            "tags": [
                "Javascript",
                "KnockoutJS"
            ]
        },
        {
            "id": "https://lorefnon.me/2012/08/12/effectively-debugging-knockoutjs-applications.html",
            "url": "https://lorefnon.me/2012/08/12/effectively-debugging-knockoutjs-applications.html",
            "title": "Effectively debugging KnockoutJS applications.",
            "date_published": "2012-08-12T00:00:00.000Z",
            "content_html": "<p>This post aims to provide some explanation about the lifecycle of dynamic data-bindings in KnockoutJS to  ease debugging of KO applications .</p>\n<p>A developer can remain perfectly oblivious of all that is going on under the hood and let the magic of declarative bindings do all the heavy-lifting of data-synchronization and it all works fine untill something unexpected happens. What now ? While most of the bugs in code can be directly resolved by inspecting the data-bind attributes manually, but if the complexity of application grows beyond a level an understanding of what goes on under the sheets becomes necessary.</p>\n<p>While UI does appear to be getting magically updated when the models change, in reality the code underneath is all plain javascript. So what happens when something doesn’t turn out to be as expected ? Where do we start debugging from ?</p>\n<p>The first and most obvious point of commencement is the observable. While we can (and sometimes might need to) begin from the observable function and dig down, debugging process is much simplified if we have a bit of familiarity with the way KO works internally. At this point I would like to underline that KO code is written very well and in general is easy to understand.</p>\n<p>This knowledge is also helpful for development of custom bindings.</p>\n<p>KO relies on bindingHandlers to manage bindings. So corresponding to every built in binding (eg. visible, text, html, value etc.)  we have a bindingHandler which has the same name. The text  binding is handled by a function <strong>ko.bindingHandlers.text</strong>, the value binding by <strong>ko.bindingHandlers.value</strong> and likewise.</p>\n<p>Let us checkout a simple example :</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;jquery-1.7.1.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;knockout-latest.debug.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      Please Enter your name :\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">&quot;value:name&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">input</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      Hello <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">&quot;text: name&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n\n<pre><code class=\"hljs javascript\">$(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;\n    <span class=\"hljs-keyword\">var</span> vmodel = &#123;\n        <span class=\"hljs-attr\">name</span>: ko.<span class=\"hljs-title function_\">observable</span>(<span class=\"hljs-string\">&quot;Lorefnon&quot;</span>)\n    &#125;\n    ko.<span class=\"hljs-title function_\">applyBindings</span>(vmodel);\n&#125;);</code></pre>\n\n<p>There are two binders involved : text-binder and value-binder. Let us inspect the <strong>ko.bindingHandlers.text</strong>in javascript.   It has a single member : update function. Yes, you guessed it right – this is the function that is called when the span is to be updated. Let us checkout what it does :</p>\n<pre><code class=\"hljs javascript\">ko.<span class=\"hljs-property\">bindingHandlers</span>[<span class=\"hljs-string\">&#x27;text&#x27;</span>] = &#123;\n    <span class=\"hljs-string\">&#x27;update&#x27;</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element, valueAccessor</span>) &#123;\n        ko.<span class=\"hljs-property\">utils</span>.<span class=\"hljs-title function_\">setTextContent</span>(element, <span class=\"hljs-title function_\">valueAccessor</span>());\n    &#125;\n&#125;;</code></pre>\n\n<p>The code is straightforward and self explanatory. You can just add a breakpoint to the update function and it will be triggered every time that particular DOM node is updated. As expected the actual DOM manipulation takes place in the <strong>ko.utils.setTextContent</strong></p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">setTextContent</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element, textContent</span>) &#123;\n     <span class=\"hljs-keyword\">var</span> value = ko.<span class=\"hljs-property\">utils</span>.<span class=\"hljs-title function_\">unwrapObservable</span>(textContent);\n     <span class=\"hljs-keyword\">if</span> ((value === <span class=\"hljs-literal\">null</span>) || (value === <span class=\"hljs-literal\">undefined</span>)) value = <span class=\"hljs-string\">&quot;&quot;</span>;\n     <span class=\"hljs-string\">&#x27;innerText&#x27;</span> <span class=\"hljs-keyword\">in</span> element ? element.<span class=\"hljs-property\">innerText</span> = value : element.<span class=\"hljs-property\">textContent</span> = value;\n     <span class=\"hljs-keyword\">if</span> (ieVersion &gt;= <span class=\"hljs-number\">9</span>) &#123;\n         <span class=\"hljs-comment\">// Believe it or not, this actually fixes an IE9 rendering bug</span>\n         <span class=\"hljs-comment\">// (See https://github.com/SteveSanderson/knockout/issues/209)</span>\n         element.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = element.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span>;\n     &#125;\n&#125;,\n</code></pre>\n\n<p>What about the other side of the code : What do you do to intercept a change in a form element ? Let us checkout the <strong>ko.bindingHandlers.value</strong></p>\n<img src=\"/images/ko.png\" />\n\n<p>As you probably have already guessed, the init function creates the bindings to intercept any change in the form element. The actual handler that is called each time when the input element changes its value is the valueUpdateHandler function defined inside init :</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> valueUpdateHandler = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;\n     <span class=\"hljs-keyword\">var</span> modelValue = <span class=\"hljs-title function_\">valueAccessor</span>();\n     <span class=\"hljs-keyword\">var</span> elementValue = ko.<span class=\"hljs-property\">selectExtensions</span>.<span class=\"hljs-title function_\">readValue</span>(element);\n     ko.<span class=\"hljs-property\">jsonExpressionRewriting</span>.<span class=\"hljs-title function_\">writeValueToProperty</span>(modelValue, allBindingsAccessor, <span class=\"hljs-string\">&#x27;value&#x27;</span>, elementValue, <span class=\"hljs-comment\">/* checkIfDifferent: */</span> <span class=\"hljs-literal\">true</span>);\n&#125;</code></pre>\n\n<p>elementValue holds the changed value which is in the next line synced back.</p>\n<p>So here is an overview of how bindings work : when you call <strong>ko.applyBindings</strong> the library traverses the DOM hunting for data-bind attributes. When it finds a data-bind attribute – it first of all figures out which bindingHandler is to be called from the part of data-bind attribute value that preceded the colon. The corresponding handler’s update method set to be called each time the value of corresponding view model attribute changes and it is the responsibility of the update method to alter the DOM node as directed by the data-bind specification.</p>\n<p>For those nodes which are editable by user (ie. the form elements) the corresponding bindingHandlers also have an init method which sets up the bindings for reverse synchronization.</p>\n<p>This summarizes the way data-bindings work under the hood. I hope that this post helps to improve your understanding of KO library.</p>\n",
            "tags": [
                "Javascript",
                "KnockoutJS"
            ]
        },
        {
            "id": "https://lorefnon.me/2012/08/11/debunking-10-common-knockoutjs-myths.html",
            "url": "https://lorefnon.me/2012/08/11/debunking-10-common-knockoutjs-myths.html",
            "title": "Debunking 10 common KnockoutJS myths",
            "date_published": "2012-08-11T00:00:00.000Z",
            "content_html": "<p>It seems that among the developer community, there exist multiple misconceptions regarding KnockoutJS. This is particularly true for developers who are not familiar with the MVVM pattern or declarative style followed by Knockout. This posts aims to clarify some of these misconceptions.</p>\n<p>I was particularly motivated to write this post after <a href=\"http://stackoverflow.com/questions/5112899/knockout-js-vs-backbone-js-vs/6340870#6340870\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">this discussion</a> at Stackoverflow.</p>\n<h1 id=\"KnockoutJS-is-tied-to-specific-server-side-back-ends\"><a href=\"#KnockoutJS-is-tied-to-specific-server-side-back-ends\" class=\"headerlink\" title=\"KnockoutJS is tied to specific server side back-ends.\"></a>KnockoutJS is tied to specific server side back-ends.</h1><p>This mainly stems from the similarities of the declarative binding style used in KO with the WPF declarative bindings. Since I do not work with Microsoft technologies, I can not really assert if the WPF declarative binding style was indeed an inspiration behind KO, however I would like to highlight that KO is strictly a client side library and an ASP.net backend (or any specific server side backend for that matter) is not mandatory. In fact KO will work happily with no server-side code at all. I strongly recommend people to checkout the basic examples presented in the site using jsfiddle and convince yourself that this is indeed the case.</p>\n<p>On a sidenote, there do exist libraries that aim to provide seamless integration layers between KO and ASP.net MVC eg. KnockoutMVC which claims to facilitate creation of complex client side applications without writing a single line of javascript. I strongly advocate against using such esoteric frameworks.</p>\n<h1 id=\"KnockoutJS-has-hard-wired-dependency-on-jQuery-and-jQuery-templating-plugin\"><a href=\"#KnockoutJS-has-hard-wired-dependency-on-jQuery-and-jQuery-templating-plugin\" class=\"headerlink\" title=\"KnockoutJS has hard-wired dependency on jQuery and jQuery-templating plugin.\"></a>KnockoutJS has hard-wired dependency on jQuery and jQuery-templating plugin.</h1><p>Again this is absolutely incorrect. The core functionality provided by KO is framework agonistic. And as far as templating is concerned integrating of third party templating engines is not very difficult. Since KO is open source you can probably find support for your favourite templating engine already available. For example the ko.mustache extension by Marcin Wtorkowski adds support for mustache templating engine.</p>\n<h1 id=\"Because-of-the-level-of-abstraction-offered-by-declarative-bindings-KnockoutJS-is-difficult-to-debug\"><a href=\"#Because-of-the-level-of-abstraction-offered-by-declarative-bindings-KnockoutJS-is-difficult-to-debug\" class=\"headerlink\" title=\"Because of the level of abstraction offered by declarative bindings, KnockoutJS is difficult to debug.\"></a>Because of the level of abstraction offered by declarative bindings, KnockoutJS is difficult to debug.</h1><p>While it is true that KO hides away the boiler plate code for data synchronization and the users are concerned with declaring the bindings in attributes, when things go wrong (either at your end or if you happen to discover a bug in the library) you will have to dig into the layers of abstraction. Fortunately in case of KO, the abstractions are not very convoluted and a basic understanding of the binding management lifecycle makes debugging pretty easy. KO source code is well written and not very difficult to understand, although that certainly is a subjective opinion.</p>\n<p>I plan to highlight some guidelines for debugging KO applications in a future post.</p>\n<h1 id=\"It-is-difficult-to-properly-test-a-KnockoutJS-application\"><a href=\"#It-is-difficult-to-properly-test-a-KnockoutJS-application\" class=\"headerlink\" title=\"It is difficult to properly test a KnockoutJS application.\"></a>It is difficult to properly test a KnockoutJS application.</h1><p>There is simply no reason for this to be true considering that KO is plain simple javascript. In particular KO is well tested and has a comprehensive test suite, which alleviates the developer from writing test cases for boilerplate code for managing data synchronizations. The domain logic is still javascript and KO does not abstract away any client-server interaction so testing the core of your application mostly involves testing your own javascript code only.</p>\n<p>Also, with a basic understanding of KO handlers, the bindingHandlers can be mocked, providing a greater control to the developer.</p>\n<h1 id=\"KnockoutJS-applications-do-not-degrade-gracefully-in-absence-of-javascript\"><a href=\"#KnockoutJS-applications-do-not-degrade-gracefully-in-absence-of-javascript\" class=\"headerlink\" title=\"KnockoutJS applications do not degrade gracefully in absence of javascript.\"></a>KnockoutJS applications do not degrade gracefully in absence of javascript.</h1><p>Graceful degradation in absense of javascript depends on the way your application has been architectured. Although KO being a pure javascript library, does not offer any support for graceful degradation in absence of javascript, nevertheless unlike many of the competing technologies it does not hinder graceful degradation.</p>\n<p>To create a KO application that degrades gracefully, just ensure that the initial state of the page that is rendered by the server suffices to convey the information that a user should see in absence of javascript. Fallback mechanisms (eg simple forms and links) should be available that provide the complete (or partial) application functionality in absence of javascript. Then when you create your view models you can instantiate them from the data already available from the DOM and future data can be loaded via ajax without refreshing the page.</p>\n<p>A good example for this functionality can be a grid. The basic HTML page served by the server can contain a simple HTML table with support for traditional links for pagination. Then you can create your view models from the data present in the table ( or ajax if a bit of redundant data load does not matter for you) and utilize KO for interactive bindings.</p>\n<p>Since KO does not use special inline markup or custom html tags, but rather simple data-bind attributes which are anyways not visible in absence of javascript, it does not hinder graceful degradation.</p>\n<h1 id=\"Although-simple-attribute-binding-works-well-designing-complex-interactive-UI-results-in-cluttered-code\"><a href=\"#Although-simple-attribute-binding-works-well-designing-complex-interactive-UI-results-in-cluttered-code\" class=\"headerlink\" title=\"Although simple attribute-binding works well, designing complex interactive UI results in cluttered code.\"></a>Although simple attribute-binding works well, designing complex interactive UI results in cluttered code.</h1><p>Again code organization is something that KO does not enforce upon you. A very nice way to make to code modular and easy to understand is to use custom bindings. Custom bindings are not something to be used as a last resort . Creating them is easy and utilizing them you can write very succinct code that is easily understandable and manageable. Infact properly using custom bindings can significantly improve performance as compared to several data-bind attributes for same property across several adjacent DOM nodes.</p>\n<p>A few people strongly believe that doing something slightly abnormal (somewhat different from the advertised use-cases) the developer has to go to great lengths in case of KnockoutJS. This is certainly not the case. KnockoutJS does an elegant job at data binding. Not only can the actual value stored in text nodes be mapped to JavaScript objects, practically any attribute and even individual styles can be mapped to JavaScript data structures. Combine with that the fact that mapping can be directed to dynamic objects which actually derive their data from other data structures and the excellent integration of KnockoutJS with jQuery templating system, EVERY single type of UI binding can be made in knockoutJS with lesser number of lines than backbone provided you craft your viewmodels and templates creatively.\n7. Doing anything serious using KnockoutJS requires verbose inline scripts.</p>\n<p>This is also incorrect. Please read the above paragraph on properly using dynamic objects and custom bindings.</p>\n<p>Yes code like</p>\n<pre><code class=\"hljs html\">The item is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">&quot;text: price() &gt; 50 ? &#x27;expensive&#x27; : &#x27;affordable&#x27;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span> today.</code></pre>\n\n<p>is certainly ugly. But you can simply define a custom attribute that depends on price using ko.computable and have that in the view-model. As a developer you already are smart enough to avoid embedding javascript application logic inside html. KO does not come in your way.</p>\n<h1 id=\"KnockoutJS-does-not-offer-a-multitude-of-widgets\"><a href=\"#KnockoutJS-does-not-offer-a-multitude-of-widgets\" class=\"headerlink\" title=\"KnockoutJS does not offer a multitude of widgets.\"></a>KnockoutJS does not offer a multitude of widgets.</h1><p>This is absolutely correct. But KO noway advertises the same. It is essentially a data-binding library that does one thing and does it well. It is not a complete application SDK or UI framework.</p>\n<h1 id=\"Integrating-KnockoutJS-with-a-restful-backend-is-difficult\"><a href=\"#Integrating-KnockoutJS-with-a-restful-backend-is-difficult\" class=\"headerlink\" title=\"Integrating KnockoutJS with a restful backend is difficult.\"></a>Integrating KnockoutJS with a restful backend is difficult.</h1><p>As I previously pointed out, KO does not abstract out client server interaction. In fact the management of your Model layer is left almost entirely to you. Having said that, if your restful backend makes data available as json, the backbone mapping plugin makes it trivial to sync server data with view models.</p>\n<p>If the structure of the data fetched from sever differs significantly from the way view models are organized, then you anyway have to write code for transforming the code.</p>\n<p>The knockout-rest plugin by Francesco Pontillo provides a very easy and intuitive way to integrate view-models with a restful backend.</p>\n<h1 id=\"Using-libraries-like-KnockoutJS-have-serious-negative-impact-on-SEO\"><a href=\"#Using-libraries-like-KnockoutJS-have-serious-negative-impact-on-SEO\" class=\"headerlink\" title=\"Using libraries like KnockoutJS have serious negative impact on SEO.\"></a>Using libraries like KnockoutJS have serious negative impact on SEO.</h1><p>If you follow the guidelines presented above on graceful degradation then there is no reason why this should happen.</p>\n<p>Even if you are not concerned about graceful degradation, and your application is heavily dependent on Ajax based content fetching,  These  guidelines from Google, can make your website crawlable.</p>\n<p>I sincerely hope that this post was successful in removing many of the common misconceptions regarding KnockoutJS and I also hope that you will be able to appreciate the power of this fantastic library. Please leave your suggestions and opinions in the comments section below. Also if you have been working on a project that enhances or extends the capabilities of KnockoutJS please feel free to drop in a link.</p>\n",
            "tags": [
                "Javascript",
                "KnockoutJS"
            ]
        }
    ]
}