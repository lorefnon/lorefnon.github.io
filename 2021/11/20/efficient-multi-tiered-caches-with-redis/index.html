<!DOCTYPE html><html class="no-js"><head> <meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/blog.css"><meta property="og:title" content="Gaurab Paul | Blog"><meta property="og:description" content="Ramblings on Web Development and software architecture"><meta name="generator" content="Hexo 5.4.0"></head><body class="blog-body" hx-boost="true"><a class="blog-summary" href="/" hx-boost="false"><h1 class="header-text">ICICLES OF THOUGHT</h1><h2 class="header-text">Ramblings on Web Development and Software Architecture</h2></a><div class="blog-sidebar"><span class="posted-date header-text" title="2021-11-20">Posted &nbsp;7 days ago</span><hr><h1 class="header-text">Tags</h1><ul class="tag-list"><li class="body-text"><a class="tag-link" href="/tags/Redis/"><img src="/images/tag.svg">Redis</a></li></ul></div><div class="blog-header"><div class="blog-header-inner header-text">Simple and efficient multi-tiered caches with Redis &amp; lua</div></div><div class="blog-main"><div class="page-content"><p><a href="https://redis.io/" target="_blank" rel="noopener external nofollow noreferrer">Redis</a> is one of the most popular in-memory stores currently. It has a minimal footprint, is blazing fast and has managed solutions available in most cloud platforms.</p>
<p>However, people using redis as a cache often use it as a simple key-value store. It is not uncommon to see usages like <code>users:by-id:1</code> pointing to a serialized User entity with id 1, and <code>users:by-email:jon@example.com</code> pointing to a serialized User entity with a specific email. In case they are the same user, we end up storing the same entity twice, with different keys.</p>
<p>In this post, we outline that it is rather straightforward to avoid this by having a secondary index for this. </p>
<p>In above scenario, this translates to <code>users:by-email:*</code> being a secondary index, pointing to user id which can be looked up from primary index. So <code>GET users:by-email:joe@example.com</code> returns <code>1</code>, and then we can lookup user by <code>GET users:by-id:1</code>. This can help us reduce memory usage through deduplication, but the caveat is that we now need multiple lookups. </p>
<p>However, these multiple lookups don&#39;t need to be multiple tcp roundtrips between the application and cache server. We can utilize lua script support to use the value of first lookup in second lookup within the same request.</p>
<p>In practice, this looks something like this:</p>
<pre><code class="hljs plaintext">EVAL &quot;local user_id = redis.call(&#x27;GET&#x27;, KEYS[1]); if (user_id == false) then return false else return redis.call(&#x27;GET&#x27;, &#x27;users:by-id:&#x27; .. user_id); end&quot; 1 &#x27;users:by-email:joe@example.com1&#x27;</code></pre>

<p>Here the first arg to eval is a lua script, here is a better formatted snippet: </p>
<pre><code class="hljs lua"><span class="hljs-keyword">local</span> user_id = redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);

<span class="hljs-keyword">if</span> (user_id == <span class="hljs-literal">false</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">-- GET returns false if primary lookup fails</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>           <span class="hljs-comment">-- will translate to a nil reply from redis</span>
<span class="hljs-keyword">else</span> 
    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;users:by-id:&#x27;</span> .. user_id); 
<span class="hljs-keyword">end</span></code></pre>

<p>The second arg is number of arguments to be passed to the script, and in this case the only arg is the secondary index key, which we access in the above script as <code>KEYS[1]</code>. Quick reminder that lua array indices start from 1 :)</p>
<p>The redis guide has <a href="https://redis.io/commands/eval#conversion-between-lua-and-redis-data-types" target="_blank" rel="noopener external nofollow noreferrer">more pointers</a> on the redis &lt;-&gt; Lua type conversions, which you might want to glance through before venturing deeper into lua scripting with redis.</p>
</div></div><div class="blog-footer body-text"><p class="copyright-container"><strong>Â© 2021 Gaurab Paul</strong></p><p>Unless otherwise mentioned in specific contexts, all code is licensed under the The MIT License and all content and artwork is licensed under CC BY-NC-SA.</p><p>The opinions expressed herein are author's personal viewpoints and may not be taken as professional recommendations from any of his previous or current employers.</p><hr><p>Header Image credit:<a href="https://www.pexels.com/photo/stainless-steel-lamp-788855/" target="_blank" rel="noreferrer noopener">Nikita Khandelwal</a></p></div><script src="https://unpkg.com/htmx.org@1.6.0/dist/htmx.min.js"></script><script src="/js/blog.js"></script></body></html>