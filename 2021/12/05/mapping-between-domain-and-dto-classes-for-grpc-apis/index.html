<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/blog.css"><title>Lorefnon | Blog | Mapping between Domain and DTO classes for gRPC APIs</title><meta property="og:title" content="Lorefnon | Blog | Mapping between Domain and DTO classes for gRPC APIs"><meta property="og:description" content="An overview of different approaches we can use to convert between the domain classes (which the business logic operates on) and the DTO classes which are exposed to the API."><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="icon" href="/images/favicon/favicon.ico"><script data-goatcounter="https://analytics.lorefnon.com/count" async src="https://analytics.lorefnon.com/count.js"></script><script src="https://unpkg.com/htmx.org@1.7.0/dist/htmx.min.js" defer></script><script src="https://unpkg.com/dompurify@2.3.6/dist/purify.min.js" defer></script><script src="/js/blog.js" defer></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Icicles of Thought" type="application/atom+xml">
</head><body class="blog-body" hx-boost="true"><div class="blog-summary"><a class="primary-link" href="/" hx-boost="false"><h1 class="header-text">Gaurab Paul</h1><h2 class="header-text">Polyglot software developer &amp; consultant passionate about web development, distributed systems and open source technologies</h2></a><div class="blog-support"><div class="blog-support-cta-container"><a class="blog-support-btn" href="https://ko-fi.com/lorefnon" target="_blank" title="Support my work"></a></div></div></div><div class="blog-sidebar"><div class="blog-support"><div class="blog-support-cta-container"><a class="blog-support-btn" href="https://ko-fi.com/lorefnon" target="_blank" title="Support my work"></a><div class="blog-support-arrow"></div><p class="support-text body-text">Support my blog and open-source work</p></div></div><h1 class="header-text">Tags</h1><ul class="tag-list"><li class="body-text"><a class="tag-link" href="/tags/gRPC/"><img src="/images/tag.svg">gRPC</a></li><li class="body-text"><a class="tag-link" href="/tags/Kotlin/"><img src="/images/tag.svg">Kotlin</a></li><li class="body-text"><a class="tag-link" href="/tags/Spring/"><img src="/images/tag.svg">Spring</a></li><li class="body-text"><a class="tag-link" href="/tags/Spring-Boot/"><img src="/images/tag.svg">Spring-Boot</a></li></ul></div><div class="blog-header blog-post-header"><div class="blog-post-header-inner"><div class="header-text">Mapping between Domain and DTO classes for gRPC APIs</div><div class="posted-date sub-header-text" title="2021-12-04">Posted &nbsp;2 years ago</div><hr class="blog-header-separator"></div></div><div class="blog-main"><div class="page-content"><p>In a <a href="/2021/09/04/bootstrapping-a-grpc-server-with-spring-boot-and-kotlin">previous post</a> we briefly explored how to build a gRPC api backend with Kotlin. </p>
<p>In particular, we saw that from the protobuf spec which defines our API, the <a href="https://grpc.io/docs/protoc-installation/" target="_blank" rel="noopener external nofollow noreferrer">protoc compiler</a> (along with language specific plugins) is able to generate classes for the language(s) in which our server (or client) is implemented. </p>
<p>To exemplify for our case (a kotlin&#x2F;JVM backend), given a proto spec like this: </p>
<pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">User</span> &#123;
  <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;
  <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;
  <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;
&#125;</code></pre>

<p>The code generator generates an immutable User java class, and an associated builder, which we can invoke like this: </p>
<pre><code class="hljs kotlin">User
    .newBuilder()
    .setId(<span class="hljs-number">1</span>)
    .setName(<span class="hljs-string">&quot;Lorefnon&quot;</span>)
    .build()</code></pre>

<p>We also get a set of kotlin extensions, which enable us to do the same thing through a more idiomatic kotlin builder: </p>
<pre><code class="hljs kotlin">user &#123;
    id = <span class="hljs-number">1</span>
    name = <span class="hljs-string">&quot;Lorefnon&quot;</span>
&#125;</code></pre>

<p>Note that in this post we mostly consider the official proto plugins for Java &amp; Kotlin (which are complementary) by Google. Generated code may substantially differ for other alternative implementations like <a href="https://github.com/marcoferrer/kroto-plus" target="_blank" rel="noopener external nofollow noreferrer">kroto-plus</a> and <a href="https://github.com/streem/pbandk" target="_blank" rel="noopener external nofollow noreferrer">pbandk</a>.</p>
<p>These classes are primarily intended for deserializing from and serializing to the protobuf format. The conventional term in the JVM ecosystem for such classes, which are primarily intended to transport the data across API boundaries is DTO (Data Transfer Object).</p>
<p>Now the question arises, what do we use in our business logic ?</p>
<h2 id="Option-1-Using-the-generated-classes-in-core-business-logic-as-well"><a href="#Option-1-Using-the-generated-classes-in-core-business-logic-as-well" class="headerlink" title="Option 1: Using the generated classes in core business logic as well."></a>Option 1: Using the generated classes in core business logic as well.</h2><p>There is nothing really preventing us from using the generated class in our business logic as well. </p>
<p>However, we should be aware of some restrictions: </p>
<ol>
<li><p>Generated DTOs are final: </p>
<p> This means that we can&#39;t inherit from these classes, can&#39;t extend them with internal fields (not part of the API) and can&#39;t add behaviors (methods) to them. </p>
</li>
<li><p>They are immutable:</p>
<p> So whenever we need to get an updated entity, we will need to clone the entity with modifications.</p>
</li>
</ol>
<p>Thus, using the DTOs as Domain classes as well works well primarily when the business logic is entirely implemented as functional services. </p>
<p>However, if you need mutability or are not so happy with <a href="https://martinfowler.com/bliki/AnemicDomainModel.html" target="_blank" rel="noopener external nofollow noreferrer">anaemic domain models</a>, we have a few options.</p>
<h2 id="Option-2-Pass-around-the-builders"><a href="#Option-2-Pass-around-the-builders" class="headerlink" title="Option 2: Pass around the builders"></a>Option 2: Pass around the builders</h2><p>One thing that may not be obvious to developers used to conventional java builders, is that the builders generated from protobuf have both getters and setters. </p>
<p>So when we need mutability, we can just use the builders and call build only once the object needs to be serialized. </p>
<p>I recommend doing this only internally within a service class, and not have the builders be passed around across services. </p>
<p>One reason for this is that in a method that receives a builder instance, we don&#39;t have any guarantee from the compiler that all non-optional values have been populated. </p>
<h2 id="Option-3-Compose-over-the-builders"><a href="#Option-3-Compose-over-the-builders" class="headerlink" title="Option 3: Compose over the builders"></a>Option 3: Compose over the builders</h2><p>A class that composes over the builder can: </p>
<ol>
<li>Ensure that any consumer never receives a partially populated builder</li>
<li>Add behavior to a builder class - I have found this to be particularly useful for things like computed values (like age derived from created_at) which logically belong in the entity class.</li>
</ol>
<p>While this would have been cumbersome &amp; boilerplate heavy in java, Kotlin&#39;s support for interface delegation comes in really handy here. </p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBuilder</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> internalBuilder: User.Builder
): UserOrBuilder <span class="hljs-keyword">by</span> internalBuilder &#123;

    <span class="hljs-comment">// To be used when constructing new objects</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(
        name: String,
        email: String
        <span class="hljs-comment">// Other fields whose presence we want to enforce</span>
    ): <span class="hljs-keyword">this</span>(
        User
            .newBuilder()
            .setName(name)
            .setEmail(email)
    )

    <span class="hljs-comment">// To be used when deserializing previously serialized entity </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(
        inputStream: InputStream
    ): <span class="hljs-keyword">this</span>(
        User.newBuilder().mergeFrom(inputStream)

        <span class="hljs-comment">// If we had successfully serialized, then we know that all mandatory fields will be present</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// But we can add validations if we are consuming multiple generations of serialized entities</span>
    )

    <span class="hljs-comment">// If needed, define similar constructors to consume ByteArray/ByteString</span>

    <span class="hljs-comment">// Define setters for fields for which you want to explicitly allow mutation</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(mail: <span class="hljs-type">String</span>)</span></span> &#123;
        internalBuilder.email = mail
    &#125;
&#125;</code></pre>

<p>The UserOrBuilder is a generated interface which contains all the getters. By delegating to this interface through the builder, we can directly invoke all the setters directly on an instance of our <code>UserBuilder</code> class, and they&#39;ll be proxied to the underlying builder.</p>
<p>By ensuring that our constructor accepts all mandatory parameters, our consumers are guaranteed to never receive partially populated builders. </p>
<p>Also, we are explicit about which fields we want to allow mutation for. </p>
<p>The only caveat with this approach is that it is quite a bit of boilerplate because a large set of fields have to enumerated over in the constructor. </p>
<h2 id="Option-4-Use-a-mapping-library-like-MapStruct"><a href="#Option-4-Use-a-mapping-library-like-MapStruct" class="headerlink" title="Option 4: Use a mapping library like MapStruct"></a>Option 4: Use a mapping library like MapStruct</h2><p>MapStruct is a really nice model mapping library for java that has good support for Kotlin and protobuf style builders. </p>
<p>One great feature of the library, as compared to many other similar model mapping libraries is that there is no reflection involved during mapping - which makes this library very performant in practice. </p>
<p>Application developers need to define mapper interfaces, and at compile time MapStruct will generate mapper classes which convert between one type to another. </p>
<p>With this library, we can define our domain classes as Kotlin (data) classes and have them mapped to&#x2F;from the API classes at the API service layer. </p>
<p>Following are the primary dependencies we need: </p>
<pre><code class="hljs kotlin">implementation(<span class="hljs-string">&quot;org.mapstruct:mapstruct:1.4.2.Final&quot;</span>)
kapt(<span class="hljs-string">&quot;org.mapstruct:mapstruct-processor:1.4.2.Final&quot;</span>)
kapt(<span class="hljs-string">&quot;no.entur.mapstruct.spi:protobuf-spi-impl:1.18&quot;</span>)</code></pre>

<p>In a spring project, we&#39;d also want MapStruct to automatically annotate generated classes with <code>@Component</code> so that we can directly inject them in our services: </p>
<pre><code class="hljs kotlin">kapt &#123;
    arguments &#123;
        arg(<span class="hljs-string">&quot;mapstruct.defaultComponentModel&quot;</span>, <span class="hljs-string">&quot;spring&quot;</span>)
    &#125;
&#125;</code></pre>

<p>Now, we can define a mapper abstract class or interface, which MapStruct will use to generate our Mappers: </p>
<pre><code class="hljs kotlin"><span class="hljs-meta">@Mapper(</span>
<span class="hljs-meta">    // We can not assign null to setters in protobuf builders</span>
<span class="hljs-meta">    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE,</span>
<span class="hljs-meta">    nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS,</span>
<span class="hljs-meta"></span>
<span class="hljs-meta">    // For collection members (repeated fields in protobuf), we should use </span>
<span class="hljs-meta">    // the add* methods rather than set* methods</span>
<span class="hljs-meta">    collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED</span>
<span class="hljs-meta">)</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DTOMapper</span> &#123;
    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mapUserFromPB</span><span class="hljs-params">(source: <span class="hljs-type">User</span>)</span></span>: UserEntity
    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mapUserToPB</span><span class="hljs-params">(source: <span class="hljs-type">UserEntity</span>)</span></span>: User
&#125;</code></pre>

<p>Here <code>User</code> entity is the class generated from protobuf, and <code>UserEntity</code> is our internal domain class.</p>
<p>For this particular example, this is all we need if our fields have the same name in both classes, and the generated classes and the domain classes use the same types. </p>
<p>In real world applications, both of these will sometimes not be true. However, to handle these special cases we can configure MapStruct with custom mappings and specify shared type mappers.</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DTOMapper</span> &#123;

    <span class="hljs-comment">// Custom mapping for field</span>
    <span class="hljs-meta">@Mappings(</span>
<span class="hljs-meta">        value = [</span>
<span class="hljs-meta">            Mapping(source = <span class="hljs-string">&quot;mailAddress&quot;</span>, target = <span class="hljs-string">&quot;email&quot;</span>)</span>
<span class="hljs-meta">        ]</span>
<span class="hljs-meta">    )</span>
    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mapUserFromPB</span><span class="hljs-params">(source: <span class="hljs-type">User</span>)</span></span>: UserEntity

    <span class="hljs-comment">// Convert between types used in Domain classes and DTOs</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">map</span><span class="hljs-params">(value: <span class="hljs-type">Date</span>)</span></span> =
        LocalDate.of(value.year, value.month, value.day)

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">map</span><span class="hljs-params">(value: <span class="hljs-type">LocalDate</span>)</span></span>: Date =
        Date.newBuilder()
            .setDay(value.dayOfMonth)
            .setMonth(value.monthValue)
            .setYear(value.year)
            .build()
&#125;</code></pre>

<p>MapStruct <a href="https://mapstruct.org/documentation/installation/" target="_blank" rel="noopener external nofollow noreferrer">docs</a> cover all possible options in much more detail.</p>
<p>In our RPC service implementations, we can inject our mappers and use them to transform inputs before delegating to internal classes, and after receiving the results from the internal classes. </p>
<pre><code class="hljs kotlin"><span class="hljs-meta">@GrpcService</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRPCService</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepo: UserRepository,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mapper: DTOMapper
) : UserServiceGrpcKt.UserServiceCoroutineImplBase() &#123;

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(request: <span class="hljs-type">UserIdRequest</span>)</span></span>: User &#123;
        <span class="hljs-keyword">return</span> mapper.mapUserToPB(userRepo.getUser(request.id))
    &#125;

&#125;</code></pre>

<p>This is the option with minimum boilerplate, but has the trade-off of needing additional heap allocations. However, it is usually an acceptable tradeoff when the types used in the DTOs often differ from the the types used in the domain classes or when we need multiple representations of the same domain class(es) in the API layer (with different set of fields).</p>
</div><div class="post-comments"><!-- .comments-target--></div><div class="post-comments" style="margin-top: 10px;"><div id="remark42"></div></div></div><div class="blog-footer body-text"><p class="copyright-container"><strong>© 2022 Gaurab Paul</strong></p><p>Unless otherwise mentioned in specific contexts, all code is licensed under the The MIT License and all content and artwork is licensed under CC BY-NC-SA.</p><p>The opinions expressed herein are author's personal viewpoints and may not be taken as professional recommendations from any of his previous or current employers.</p></div></body></html>