<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/blog.css"><title>Lorefnon | Blog | In-Memory Zipping in Ruby</title><meta property="og:title" content="Lorefnon | Blog | In-Memory Zipping in Ruby"><meta property="og:description" content="Ramblings on Web Development and software architecture"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="icon" href="/images/favicon/favicon.ico"><script src="https://unpkg.com/htmx.org@1.7.0/dist/htmx.min.js" defer></script><script src="https://unpkg.com/dompurify@2.3.6/dist/purify.min.js" defer></script><script src="/js/blog.js" defer></script><script>window.goatcounter = {no_onload: true}

htmx.on('htmx:load', (e) => {
    window.goatcounter.count({
        path: location.pathname + location.search + location.hash,
    })
})</script><script data-goatcounter="https://analytics.lorefnon.com/count" async src="https://analytics.lorefnon.com/count.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body class="blog-body" hx-boost="true"><div class="blog-summary"><a class="primary-link" href="/" hx-boost="false"><h1 class="header-text">Gaurab Paul</h1><h2 class="header-text">Polyglot software developer &amp; consultant passionate about web development, distributed systems and open source technologies</h2></a><div class="blog-support"><div class="blog-support-cta-container"><a class="blog-support-btn" href="https://ko-fi.com/lorefnon" target="_blank" title="Support my work"></a></div></div></div><div class="blog-sidebar"><div class="blog-support"><div class="blog-support-cta-container"><a class="blog-support-btn" href="https://ko-fi.com/lorefnon" target="_blank" title="Support my work"></a><div class="blog-support-arrow"></div><p class="support-text body-text">Support my blog and open-source work</p></div></div><h1 class="header-text">Tags</h1><ul class="tag-list"><li class="body-text"><a class="tag-link" href="/tags/Ruby/"><img src="/images/tag.svg">Ruby</a></li></ul></div><div class="blog-header blog-post-header"><div class="blog-post-header-inner"><div class="header-text">In-Memory Zipping in Ruby</div><div class="posted-date sub-header-text" title="2014-09-03">Posted &nbsp;8 years ago</div><hr class="blog-header-separator"></div></div><div class="blog-main"><div class="flex-row post-warning"><img src="/images/primary/alert-triangle.svg" style="margin-right: 1rem">This post has not been updated in quite some time and the content here may be out of date 
or not reflect my current my recommedation in the matter.</div><div class="page-content"><p><a href="https://github.com/rubyzip/rubyzip" target="_blank" rel="noopener external nofollow noreferrer">Rubyzip</a> is pretty much the defacto solution for manipulating zip files in ruby. However an underdocumented feature of this library is that it allows for creating zip files in memory ie. without actually writing anything to a file.</p>
<p>There are many situations when this can come in handy. For example in a Web application it may be faster to zip a small number of files on the fly and deliver it to client without writing to disc. This is especially handy in cloud environments where direct disc access is prohibited.</p>
<p>This can be accomplished as follows:</p>
<pre><code class="hljs ruby">file_stream = Zip::ZipOutputStream.write_buffer <span class="hljs-keyword">do</span> |<span class="hljs-params">zip</span>|
  zip.put_next_entry <span class="hljs-string">&quot;hello.txt&quot;</span>
  zip.print <span class="hljs-string">&quot;Hello World&quot;</span>
<span class="hljs-keyword">end</span></code></pre>

<p>The above creates a zip file with a single file hello.txt containing the text &quot;Hello World&quot;</p>
<p>Creating directory structures is just as easy:</p>
<pre><code class="hljs ruby">file_stream = Zip::ZipOutputStream.write_buffer <span class="hljs-keyword">do</span> |<span class="hljs-params">zip</span>|
  zip.put_next_entry <span class="hljs-string">&quot;dir1/hello.txt&quot;</span>
  zip.print <span class="hljs-string">&quot;Hello&quot;</span>
  zip.put_next_entry <span class="hljs-string">&quot;dir2/hello.txt&quot;</span>
  zip.print <span class="hljs-string">&quot;World&quot;</span>
<span class="hljs-keyword">end</span></code></pre>

<p>Finally, before we can read from the stream we will have to rewind it first. As an illustrative example the following shows a typical Rails controller that renders a zipped file to client.</p>
<pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeController</span> &lt; <span class="hljs-title class_ inherited__">ApplicationController</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">some_action</span>
    file_stream = Zip::ZipOutputStream.write_buffer <span class="hljs-keyword">do</span> |<span class="hljs-params">zip</span>|
      zip.put_next_entry <span class="hljs-string">&quot;dir1/hello.txt&quot;</span>
      zip.print <span class="hljs-string">&quot;Hello&quot;</span>
      zip.put_next_entry <span class="hljs-string">&quot;dir2/hello.txt&quot;</span>
      zip.print <span class="hljs-string">&quot;World&quot;</span>
    <span class="hljs-keyword">end</span>
    file_stream.rewind
    respond_to <span class="hljs-keyword">do</span> |<span class="hljs-params">format</span>|
      format.zip <span class="hljs-keyword">do</span>
        send_data file_stream.read, <span class="hljs-symbol">filename:</span> <span class="hljs-string">&quot;zip_file.zip&quot;</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>

<p>A user visiting this action will be downloading a file named zip_file.zip containing two files in their respective directories.</p>
<p>For <code>format.zip</code> to be available we will have to register <code>application/zip</code> mimetype. Add the following to an initializer:</p>
<pre><code class="hljs ruby">Mime::Type.register <span class="hljs-string">&quot;application/zip&quot;</span>, <span class="hljs-symbol">:zip</span></code></pre>

<p>This concludes this small article. Please feel free to leave your suggestions in the comments below.</p>
</div></div><div class="blog-footer body-text"><p class="copyright-container"><strong>Â© 2022 Gaurab Paul</strong></p><p>Unless otherwise mentioned in specific contexts, all code is licensed under the The MIT License and all content and artwork is licensed under CC BY-NC-SA.</p><p>The opinions expressed herein are author's personal viewpoints and may not be taken as professional recommendations from any of his previous or current employers.</p></div></body></html>